{
    "version": "https://jsonfeed.org/version/1",
    "title": "Khala • All posts by \"pikachu\" category",
    "description": "GLHF",
    "home_page_url": "https://mobius-0.github.io",
    "items": [
        {
            "id": "https://mobius-0.github.io/security/pikachu/pikachu-xss/",
            "url": "https://mobius-0.github.io/security/pikachu/pikachu-xss/",
            "title": "pikachu-XSS",
            "date_published": "2022-12-03T12:20:55.000Z",
            "content_html": "<h1 id=\"反射型xssget\"><a class=\"anchor\" href=\"#反射型xssget\">#</a> 反射型 XSS（get）</h1>\n<h2 id=\"过程\"><a class=\"anchor\" href=\"#过程\">#</a> 过程</h2>\n<ol>\n<li>在输入框中输入任意字段，查看页面代码可以发现输入字段已经被插入到了页面之中</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/V5JlmdS31TrwkxC.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>这里可以尝试直接输入相应的 XSS payload，如</li>\n</ol>\n<pre><code>&lt;script&gt;alert(1)&lt;/script&gt;\n&lt;details+open+ontoggle=prompt(1)&gt;\n&lt;svg/onload=confirm(1)&gt;\n</code></pre>\n<p>等</p>\n<ol start=\"3\">\n<li>输入的时候可以发现输入框有输入字符的上限（并且该输入框在测试时还可以发现其对输入字符髌骨无限制，特殊字符如 / 等可以直接插入到前端代码中），但这些不算很重要，我们可以直接在前端的代码上修改，也可以在网页的 url 上根据规律进行插入</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/Vbk6tW7wDxhspGz.png\" alt=\"\" /></p>\n<ol start=\"4\">\n<li>反弹结果</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/AB1TUmItyG54pMq.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/OqeGpAaHP6uxFit.png\" alt=\"\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>GET 方式要更容易被利用，因为相关元素可以直接通过网页 URL 直接提交，通常的利用形式为将带有跨站脚本的 URL 伪装后发送给目标</p>\n<h1 id=\"反射型xsspost\"><a class=\"anchor\" href=\"#反射型xsspost\">#</a> 反射型 XSS（post）</h1>\n<h2 id=\"过程-2\"><a class=\"anchor\" href=\"#过程-2\">#</a> 过程</h2>\n<ol>\n<li>由于使用的是 post 方法，这里需要使用 burp suite 进行数据包的抓取</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/ULb8cZdWiSGvr7P.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>根据重放可知字符也已经插入页面代码</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/I72ifcL89ymE1eR.png\" alt=\"\" /></p>\n<ol start=\"3\">\n<li>修改抓取的数据包，将 message 修改为 XSS 的 payload</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/aBiIjJ1vV8hQkuC.png\" alt=\"\" /></p>\n<ol start=\"4\">\n<li>放行后输出结果，可以看到 payload 已经插入页面代码中</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/QzElqaYN67yZdpF.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/iMCDozdOaXBhxHm.png\" alt=\"\" /></p>\n<h2 id=\"总结-2\"><a class=\"anchor\" href=\"#总结-2\">#</a> 总结</h2>\n<p>POST 方式相对 GET 要更难被利用，但这同样存在安全隐患，这里就通过对数据包的篡改完成了 XSS 的 payload 插入，主要的利用方式会在 XSS 之盲打中会介绍</p>\n<h1 id=\"存储型xss\"><a class=\"anchor\" href=\"#存储型xss\">#</a> 存储型 XSS</h1>\n<h2 id=\"过程-3\"><a class=\"anchor\" href=\"#过程-3\">#</a> 过程</h2>\n<ol>\n<li>首先同样输入任意值，测试其是否存在对特殊字符的过滤</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/dtBg7R6PXwze3Mv.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>直接输入 XSS 的 payload，反弹结果，同时可以查看页面代码，发现 payload 已经被插入其中</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/gxzHjGslwbOYSq9.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/smBoa5QdLlWzgTf.png\" alt=\"\" /></p>\n<h2 id=\"总结-3\"><a class=\"anchor\" href=\"#总结-3\">#</a> 总结</h2>\n<p>存储型 XSS 在道理上和反射型差不多，区别在于存储型会被存储起来，而反射型则是一次性的</p>\n<h1 id=\"dom型xss\"><a class=\"anchor\" href=\"#dom型xss\">#</a> DOM 型 XSS</h1>\n<h2 id=\"过程-4\"><a class=\"anchor\" href=\"#过程-4\">#</a> 过程</h2>\n<ol>\n<li>同样首先输入任意字符，查看页面元素可知字符已被插入到前端中</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/coW2JHhNR79Qv16.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>输入 payload： <code>javascript:alert(1)</code>  尝试触发漏洞，查看页面元素可知 payload 已被插入到前端，点击 <code>what do you see？</code> 可以看到漏洞已触发</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/qJwzxBHbT5e1jNm.png\" alt=\"\" /></p>\n<h2 id=\"总结-4\"><a class=\"anchor\" href=\"#总结-4\">#</a> 总结</h2>\n<p>这类型漏洞危害性不算非常大，但依旧需要留意</p>\n<h1 id=\"dom型xss-x\"><a class=\"anchor\" href=\"#dom型xss-x\">#</a> DOM 型 XSS-X</h1>\n<h2 id=\"过程-5\"><a class=\"anchor\" href=\"#过程-5\">#</a> 过程</h2>\n<ol>\n<li>与上一个关卡相同，先输入任意值，在页面元素中查看相关信息</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/CoBtrZPh4djYGKw.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>然后输入 payload 尝试触发漏洞，随后查看 payload 是否已经插入至页面元素中</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/j98Bvde3KuTPcEx.png\" alt=\"\" /></p>\n<h2 id=\"总结-5\"><a class=\"anchor\" href=\"#总结-5\">#</a> 总结</h2>\n<p>这类型漏洞在某些方面与反射型 XSS 类似，它们同样都是通过 url 来获取输入，实际上在观察 url 内容后就可以发现 url 中有我们先前的输入 <code>javascript%3Aalert(1)</code> ，其中 <code>:</code>  在 url 内表现为 <code>%3A</code> ，这些符号都有固定的翻译对应，例如空格就会翻译为 <code>%20</code> 。</p>\n<h1 id=\"xss之盲打\"><a class=\"anchor\" href=\"#xss之盲打\">#</a> XSS 之盲打</h1>\n<h2 id=\"过程-6\"><a class=\"anchor\" href=\"#过程-6\">#</a> 过程</h2>\n<ol>\n<li>老规矩，先输入任意值，在前端代码中并没有看到相应的输出，所以这里需要登录管理后台查看结果</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/WasLb8V4YG7tCju.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>随后输入 payload <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>  尝试触发漏洞，由于前端并没有对应代码显示，所以需要到后台查看漏洞是否被触发。可以看到弹窗，漏洞已经被触发。</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/9PvRs8C3tpLwmMy.png\" alt=\"\" /></p>\n<h2 id=\"总结-6\"><a class=\"anchor\" href=\"#总结-6\">#</a> 总结</h2>\n<p>盲打主要指的是这么一种攻击场景，前端输入的内容只有在后端才能看到，这类型的攻击通常具有随机性，首先输入框有可能存在对特殊字符和语句的过滤，导致跨站脚本上传失败，即使能够上传成功，在后端也有可能有过滤或验证，导致脚本不一定会被触发。但是危害同样很大，如果不存在上述验证，那么完全可以将脚本替换为获取 cookie 的脚本，如果管理员登陆就有可能会被盗取 cookie，导致管理权限的外泄。</p>\n<h1 id=\"xss过滤\"><a class=\"anchor\" href=\"#xss过滤\">#</a> XSS 过滤</h1>\n<h2 id=\"过程-7\"><a class=\"anchor\" href=\"#过程-7\">#</a> 过程</h2>\n<ol>\n<li>\n<p>依旧是老规矩，首先随意输入查看过滤情况，可以发现如 <code>&lt;script&gt;</code>  或双写关键词 <code>&lt;scrscriptipt&gt;</code>  等都被过滤掉了</p>\n</li>\n<li>\n<p>尝试修改 payload 格式，发现大写形式是不会被过滤的，写入后成功触发漏洞</p>\n</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/x6XeM7ckWntEDhH.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/vfBMTFm1Qa4qglS.png\" alt=\"\" /></p>\n<h2 id=\"总结-7\"><a class=\"anchor\" href=\"#总结-7\">#</a> 总结</h2>\n<p>这里漏洞的问题还是在于过滤的规则不够完善，查看源代码可以发现，实际上是只对 <code>&lt;script</code>  进行了过滤，简单点的绕过可以通过改变大小写来实现，同时也可以使用其他 payload 如 img 的标签 <code>&lt;img src=x onerror=&quot;alert(1)&quot;&gt;</code>  来实现绕过</p>\n<h1 id=\"xss之htmlspecialchars\"><a class=\"anchor\" href=\"#xss之htmlspecialchars\">#</a> XSS 之 htmlspecialchars</h1>\n<h2 id=\"过程-8\"><a class=\"anchor\" href=\"#过程-8\">#</a> 过程</h2>\n<ol>\n<li>仍旧老规矩，随意输入字符，查看是否插入至前端中</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/UKlvPJfGhw9qraN.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>根据 htmlspecialchars 方法默认不对 <code>'</code>  进行处理的特点，我们可以构造 payload <code>1' oneclick='alert(1)'</code> ，输入后查看结果</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/imwbCQnuKe5stIf.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/Q8Hi6MuhG2zmelE.png\" alt=\"\" /></p>\n<h2 id=\"总结-8\"><a class=\"anchor\" href=\"#总结-8\">#</a> 总结</h2>\n<p>htmlspecialchars () 函数功能为把预定的字符转换为 HTML 实体，当前预定义的字符有：</p>\n<pre><code> &amp; → &amp;amp\n &quot; → &amp;quot\n ' → &amp;apos\n &lt; → &amp;lt\n &gt; → &amp;gt\n</code></pre>\n<h1 id=\"xss之href输出\"><a class=\"anchor\" href=\"#xss之href输出\">#</a> XSS 之 href 输出</h1>\n<h2 id=\"过程-9\"><a class=\"anchor\" href=\"#过程-9\">#</a> 过程</h2>\n<ol>\n<li>随意输入字符，查看页面源代码插入位置</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/ZAHn1MfB73sbXTz.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>此处可以直接构造 payload <code>javascript:alert(1)</code> ，输入后查看结果</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/3XBuyI1HLkNDaMT.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/qBDJt5mx3flyzCF.png\" alt=\"\" /></p>\n<h2 id=\"总结-9\"><a class=\"anchor\" href=\"#总结-9\">#</a> 总结</h2>\n<p>这个漏洞比较简单，此处我们可以只允许 http、https，其次再进行 htmlspecialchars 处理</p>\n<h1 id=\"xss之js输出\"><a class=\"anchor\" href=\"#xss之js输出\">#</a> XSS 之 js 输出</h1>\n<h2 id=\"过程-10\"><a class=\"anchor\" href=\"#过程-10\">#</a> 过程</h2>\n<ol>\n<li>首先随意输入字符，发现代码中使用 $ms 来传递参数</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/m3NqsvaHCuiAyZY.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>构造 payload 尝试闭合掉下方的 if 判断句 <code>1'&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/2lPxNofSVdvamrB.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/04/yjbYkTQBXlG7zWg.png\" alt=\"\" /></p>\n<h2 id=\"总结-10\"><a class=\"anchor\" href=\"#总结-10\">#</a> 总结</h2>\n<p>这里主要的操作是再输入框后增加前端代码完成对原有代码的闭合，将原来的判断语句直接排除在外，这样就避免了 if 的验证，实现绕过。</p>\n",
            "tags": [
                "漏洞",
                "渗透测试",
                "靶场",
                "pikachu",
                "XSS"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/pikachu/pikachu-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/",
            "url": "https://mobius-0.github.io/security/pikachu/pikachu-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/",
            "title": "pikachu-暴力破解",
            "date_published": "2022-12-03T12:19:55.000Z",
            "content_html": "<h1 id=\"基于表单的暴力破解\"><a class=\"anchor\" href=\"#基于表单的暴力破解\">#</a> 基于表单的暴力破解</h1>\n<h2 id=\"过程\"><a class=\"anchor\" href=\"#过程\">#</a> 过程</h2>\n<p>这里本质上还是利用字典来进行用户名和密码的暴力破解，不过对于 burp suite 这类比较全面工具来说，他自己自带的字典爆破的功能就相对简单了点，并没有字典内字符相互拼接的功能，只能简单的进行排列组合。</p>\n<ol>\n<li>首先在框中随意输入字符，用 burp suite 进行数据包抓取</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/UuzCZHMX5NPOsxv.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>将数据包转发至 Intruder，选择爆破的位置，加入自己准备好的字典</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/WbldrFI4UCvyOjX.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/HBQizml95WTDtyG.png\" alt=\"\" /></p>\n<ol start=\"3\">\n<li>开始攻击，完成后查看结果，通常此时成功所返回的数据包长度与失败的不同，所以一般只需要查看这些请求即可</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/SaCurRQTGPcE7jZ.png\" alt=\"\" /></p>\n<p>这个时候可以看到这个请求包的长度有点问题，查看响应结果可知爆破成功</p>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/MesWCT1fUqnioxv.png\" alt=\"\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>这里的爆破还是较为简单的，不过后来查询数据库拥有的用户时发现实际上由三个账户可以登录，但实际上只爆破出来了一个，主要原因在于字典不够全，当然这里主要靠平时的测试积累，或者直接盲猜</p>\n<h1 id=\"验证码绕过on-server\"><a class=\"anchor\" href=\"#验证码绕过on-server\">#</a> 验证码绕过（on server）</h1>\n<h2 id=\"过程-2\"><a class=\"anchor\" href=\"#过程-2\">#</a> 过程</h2>\n<ol>\n<li>与上一个实验相同，随意填入用户名和密码，正确填入验证码，点击登录，同时用 burp suite 进行抓包</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/9xXt2PKrqfcyI3k.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>将抓取数据包发送至重放器（Repeater），修改用户名或密码发送，分析回显信息，发现验证码在后端可以重复使用</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/zTqSjriaY7J5nfB.png\" alt=\"\" /><br />\n<img data-src=\"https://s2.loli.net/2022/12/03/Q5la8sHAIjk4NYh.png\" alt=\"\" /></p>\n<ol start=\"3\">\n<li>那么将数据包内容发送至攻击器（Intruder），用类似的操作进行爆破</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/QtNYU8ORFVxmg94.png\" alt=\"\" /></p>\n<ol start=\"4\">\n<li>最后爆破成功</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/c8dblZBoYhF1Tfe.png\" alt=\"\" /></p>\n<h2 id=\"总结-2\"><a class=\"anchor\" href=\"#总结-2\">#</a> 总结</h2>\n<p>这里测试能够成功原因在于登录平台后端对验证码的验证并不严谨，单一生成的验证码可以多次使用，这就留下了非常大的安全隐患。后期可以设置验证码的存活时间，以避免长线的字典爆破。</p>\n<h1 id=\"验证码绕过on-client\"><a class=\"anchor\" href=\"#验证码绕过on-client\">#</a> 验证码绕过（on client）</h1>\n<h2 id=\"过程-3\"><a class=\"anchor\" href=\"#过程-3\">#</a> 过程</h2>\n<ol>\n<li>随意填入用户名与密码，正确填入验证码，点击登录，同时用 burp suite 进行抓包</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/kSO5WI8DUjawxQN.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>将抓取数据包发送至重放器（Repeater），修改验证码字段，发现前端代码在验证码为空时依然能通过验证</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/6PLl2QseOVmfvCg.png\" alt=\"\" /></p>\n<ol start=\"3\">\n<li>于是将抓取数据包发送至攻击器（Intruder），进行类似的爆破操作即可</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/br8zXs6pacdSQtf.png\" alt=\"\" /></p>\n<h2 id=\"总结-3\"><a class=\"anchor\" href=\"#总结-3\">#</a> 总结</h2>\n<p>这里最大的问题在于验证代码放在前端，并且存在隐患巨大的漏洞，不仅易于绕过，同时这样源代码也容易被窃取</p>\n<h1 id=\"token防爆破\"><a class=\"anchor\" href=\"#token防爆破\">#</a> token 防爆破？</h1>\n<p>这段其实没有做出结果来，还是找的网上的过程学习之后再打出来的，但是个人认为网络上的通关过程也不是很好，在爆破的时候也只是对密码和 token 两个值进行爆破，并没有对用户名进行操作，而我当时则是同时对三个值进行爆破，折磨了一个下午也没有结果，最后按网络过程后才出了结果。</p>\n<h2 id=\"过程-4\"><a class=\"anchor\" href=\"#过程-4\">#</a> 过程</h2>\n<ol>\n<li>首先将抓取的登陆数据包发送到攻击器（Intruder），设置 attack type 为 pitchfork，并选中密码和 token 作为爆破字段</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/wjcNpfeGqSgYtZu.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>根据顺序加载对应的 payload 集，如 payload 集 1 加载密码字典，payload 集 2 设置为 recursive grep</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/GKe2MEOL4NqpwFy.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/qz5UvkFEAxCT7uL.png\" alt=\"\" /></p>\n<ol start=\"3\">\n<li>在 grep-extract 下添加 token 的抓取</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/E3RFUuIol16rxms.png\" alt=\"\" /></p>\n<ol start=\"4\">\n<li>由于涉及递归和重定向，需要新建线程数为 1 的进程资源，重定向选项设置为 always</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/iO1UMKckhmzGFTY.png\" alt=\"\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/HYqUipn46W2dIPJ.png\" alt=\"\" /></p>\n<ol start=\"5\">\n<li>随后直接进行攻击即可</li>\n</ol>\n<p><img data-src=\"https://s2.loli.net/2022/12/03/Gci7VIE81eKRqyL.png\" alt=\"\" /></p>\n<h2 id=\"总结-4\"><a class=\"anchor\" href=\"#总结-4\">#</a> 总结</h2>\n<p>问题主要还是出在 token 出现在前端代码上，并且上一个登录所生成的 token 用作下一个登陆的 token，这样就留下了许多的操作空间。</p>\n",
            "tags": [
                "漏洞",
                "渗透测试",
                "靶场",
                "pikachu"
            ]
        }
    ]
}