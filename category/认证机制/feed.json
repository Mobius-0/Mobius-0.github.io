{
    "version": "https://jsonfeed.org/version/1",
    "title": "Khala • All posts by \"认证机制\" category",
    "description": "GLHF",
    "home_page_url": "https://mobius-0.github.io",
    "items": [
        {
            "id": "https://mobius-0.github.io/security/WebNote/Authentication/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/",
            "url": "https://mobius-0.github.io/security/WebNote/Authentication/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/",
            "title": "权限系统设计模型",
            "date_published": "2022-12-06T03:50:35.000Z",
            "content_html": "<p>常见的权限设计模式有以下几种：</p>\n<ul>\n<li>自主访问控制 (Discretionary Access Control, DAC)</li>\n<li>强制访问控制 (Mandatory Access Control, MAC)</li>\n<li>基于角色的访问控制 (Role-Based Access Control, RBAC)</li>\n<li>基于属性的权限验证 (Attribute-Based Access Control, ABAC)</li>\n</ul>\n<p>常用的概念有：</p>\n<ul>\n<li>用户：发起操作的主体</li>\n<li>对象：发起操作的客体，即操作的对象</li>\n<li>权限：用来指代对某对象的一种 / 一类操作</li>\n<li>权限控制表 (Access Control List, ACL): 描述用户与权限之间关系的数据表</li>\n<li>权限控制矩阵 (Access Control Matrix): 一套抽象、形式化的安全性模型。这套模型描述了电脑系统中的安全保护状态，各别表示其下的每个附属子体，对于系统中的每个对象，其所拥有的权限。</li>\n</ul>\n<p>DAC 根据 ACL 的信息来决定用户是否能对某个对象进行操作。而拥有某个对象权限的用户，又可以将该对象的权限分配给其他用户，所以这种模型被称为自主（Discretionary）访问控制。</p>\n<p>由于 DAC 权限控制较为分散，每个用户和对象都有一些权限标识，所以引入了 MAC 。每个用户和对象都有权限标识，用户是否能操作取决于双方的权限标识关系。这种方式不能灵活的授权，适合权限控制较为严格的场景。</p>\n<p>RBAC 则是迄今为止最为普及的权限设计模型，它引入了角色 (Role) 的概念。 每个用户可以关联一个或多个角色，每个角色也可以关联一个或多个权限。 当需要新的权限配置时，可以根据需求灵活创建角色。</p>\n<p>不同于 RBAC 按角色进行关联， ABAC 根据属性进行关联。通常来说，属性分为几类：用户属性、环境属性（例如时间）、操作属性（当前操作）、对象属性。ABAC 则通过动态计算一个或一组属性来是否满足对应条件来进行授权判断。</p>\n",
            "tags": [
                "权限设置"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Authentication/%E6%8C%91%E6%88%98%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6/",
            "url": "https://mobius-0.github.io/security/WebNote/Authentication/%E6%8C%91%E6%88%98%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6/",
            "title": "挑战/应答机制",
            "date_published": "2022-12-06T03:42:53.000Z",
            "content_html": "<p><img data-src=\"https://s2.loli.net/2022/12/06/jfn73rPNgUbDIA5.png\" alt=\"\" /></p>\n<h1 id=\"认证过程\"><a class=\"anchor\" href=\"#认证过程\">#</a> 认证过程</h1>\n<p>顾名思义，基于挑战 / 应答（Challenge/Response）方式的身份认证系统就是每次认证时认证服务器端都给客户端发送一个不同的 &quot;挑战&quot; 字串，客户端程序收到这个 &quot;挑战&quot; 字串后，做出相应的 &quot;应答&quot;, 以此机制而研制的系统。认证过程为：</p>\n<ol>\n<li>客户向认证服务器发出请求，要求进行身份认证；</li>\n<li>认证服务器从用户数据库中查询用户是否是合法的用户，若不是，则不做进一步处理；</li>\n<li>认证服务器内部产生一个随机数，作为 &quot;提问&quot;，发送给客户；</li>\n<li>客户将用户名字和随机数合并，使用单向 Hash 函数（例如 MD5 算法）生成一个字节串作为应答；</li>\n<li>认证服务器将应答串与自己的计算结果比较，若二者相同，则通过一次认证；否则，认证失败；</li>\n<li>认证服务器通知<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUUlQTIlRTYlODglQjclRTglQUUlQTQlRTglQUYlODE=\">客户认证</span>成功或失败。</li>\n</ol>\n<p>以后的认证由客户不定时地发起，过程中没有了客户认证请求一步。两次认证的时间间的密钥隔不能太短，否则就给网络、客户和认证服务器带来太大的开销；也不能太长，否则不能保证用户不被他人盗用 IP 地址，一般定为 1-2 分钟。</p>\n<h1 id=\"密钥的分配和管理\"><a class=\"anchor\" href=\"#密钥的分配和管理\">#</a> 密钥的分配和管理</h1>\n<p>密钥的分配由维护模块负责，当用户进行注册时，自行设定自己的口令字。用户由口令字生成。</p>\n<p>一个口令字必须经过两次口令字检查。第一次由注册程序检查，强制口令字必须有足够的长度（如 8 个字符）。口令字被加密后送入数据库中，这个口令字标记为 ' 未检查的 '。第二次，由离线的口令字<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTMlODAlRTYlOUYlQTUlRTUlQjclQTUlRTUlODUlQjc=\">检查工具</span>进行检查，将<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkMlQjElRTUlOEYlQTMlRTQlQkIlQTQ=\">弱口令</span>字进行标记，当下一次<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclOTQlQTglRTYlODglQjclRTglQUUlQTQlRTglQUYlODE=\">用户认证</span>时，认证服务器将强制用户修改口令字。</p>\n<p>密钥的在线修改由认证服务器完成，它的过程与认证过程基本类似。</p>\n",
            "tags": [
                "挑战/应答",
                "S/Key协议"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Authentication/Kerberos/",
            "url": "https://mobius-0.github.io/security/WebNote/Authentication/Kerberos/",
            "title": "Kerberos",
            "date_published": "2022-12-06T03:20:53.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>Kerberos 协议起源于美国麻省理工学院 Athena 项目，基于公私钥加密体制，为分布式环境提供双向验证，在 RFC 1510 中被采纳，Kerberos 是 Windows 域环境中的默认身份验证协议。</p>\n<p>简单地说，Kerberos 提供了一种单点登录 (Single Sign-On, SSO) 的方法。考虑这样一个场景，在一个网络中有不同的服务器，比如，打印服务器、邮件服务器和文件服务器。这些服务器都有认证的需求。很自然的，不可能让每个服务器自己实现一套认证系统，而是提供一个中心认证服务器 (Authentication Server, AS) 供这些服务器使用。这样任何客户端就只需维护一个密码就能登录所有服务器。</p>\n<p>Kerberos 协议是一个基于票据 (Ticket) 的系统，在 Kerberos 系统中至少有三个角色：认证服务器 (AS)，客户端 (Client) 和普通服务器 (Server)。</p>\n<p>认证服务器对用户进行验证，并发行供用户用来请求会话票据的 TGT (票据授予票据)。票据授予服务 (TGS) 在发行给客户的 TGT 的基础上，为网络服务发行 ST (会话票据)。</p>\n<p>在 Kerberos 系统中，客户端和服务器都有一个唯一的名字，叫做 Principal。同时，客户端和服务器都有自己的密码，并且它们的密码只有自己和认证服务器 AS 知道。</p>\n<h1 id=\"基本概念\"><a class=\"anchor\" href=\"#基本概念\">#</a> 基本概念</h1>\n<ul>\n<li>\n<p>Principal (安全个体)</p>\n<ul>\n<li>被认证的个体，有一个名字 (name) 和口令 (password)</li>\n</ul>\n</li>\n<li>\n<p>KDC (Key Distribution Center)</p>\n<ul>\n<li>提供 ticket 和临时的会话密钥的网络服务</li>\n</ul>\n</li>\n<li>\n<p>Ticket</p>\n<ul>\n<li>一个记录，用户可以用它来向服务器证明自己的身份，其中包括用户的标识、会话密钥、时间戳，以及其他一些信息。Ticket 中的大多数信息都被加密，密钥为服务器的密钥</li>\n</ul>\n</li>\n<li>\n<p>Authenticator</p>\n<ul>\n<li>一个记录，其中包含一些最近产生的信息，产生这些信息需要用到用户和服务器之间共享的会话密钥</li>\n</ul>\n</li>\n<li>\n<p>Credentials</p>\n<ul>\n<li>一个 ticket 加上一个秘密的会话密钥</li>\n</ul>\n</li>\n<li>\n<p>Authentication Server (AS)</p>\n<ul>\n<li>通过 long-term key 认证用户</li>\n<li>AS 给予用户 ticket granting ticket 和 short-term key</li>\n<li>认证服务</li>\n</ul>\n</li>\n<li>\n<p>Ticket Granting Server (TGS)</p>\n<ul>\n<li>通过 short-term key 和 Ticket Granting Ticket 认证用户</li>\n<li>TGS 发放 tickets 给用户以访问其他的服务器</li>\n<li>授权和访问控制服务</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"简化的认证过程\"><a class=\"anchor\" href=\"#简化的认证过程\">#</a> 简化的认证过程</h1>\n<ol>\n<li>\n<p>客户端向服务器发起请求，请求内容是：客户端的 principal，服务器的 principal</p>\n</li>\n<li>\n<p>AS 收到请求之后，随机生成一个密码 Kc, s (session key), 并生成以下两个票据返回给客户端</p>\n<ul>\n<li>给客户端的票据，用客户端的密码加密，内容为随机密码，session，server_principal</li>\n<li>给服务器端的票据，用服务器的密码加密，内容为随机密码，session，client_principal</li>\n</ul>\n</li>\n<li>\n<p>客户端拿到了第二步中的两个票据后，首先用自己的密码解开票据，得到 Kc、s，然后生成一个 Authenticator，其中主要包括当前时间和 Ts,c 的校验码，并且用 SessionKey Kc,s 加密。之后客户端将 Authenticator 和给 server 的票据同时发给服务器</p>\n</li>\n<li>\n<p>服务器首先用自己的密码解开票据，拿到 SessionKey Kc,s，然后用 Kc,s 解开 Authenticator，并做如下检查</p>\n<ul>\n<li>检查 Authenticator 中的时间戳是不是在当前时间上下 5 分钟以内，并且检查该时间戳是否首次出现。如果该时间戳不是第一次出现，那说明有人截获了之前客户端发送的内容，进行 Replay 攻击。</li>\n<li>检查 checksum 是否正确</li>\n<li>如果都正确，客户端就通过了认证</li>\n</ul>\n</li>\n<li>\n<p>服务器段可选择性地给客户端回复一条消息来完成双向认证，内容为用 session key 加密的时间戳</p>\n</li>\n<li>\n<p>客户端通过解开消息，比较发回的时间戳和自己发送的时间戳是否一致，来验证服务器</p>\n</li>\n</ol>\n<h1 id=\"完整的认证过程\"><a class=\"anchor\" href=\"#完整的认证过程\">#</a> 完整的认证过程</h1>\n<p>上方介绍的流程已经能够完成客户端和服务器的相互认证。但是，比较不方便的是每次认证都需要客户端输入自己的密码。</p>\n<p>因此在 Kerberos 系统中，引入了一个新的角色叫做：票据授权服务 (TGS - Ticket Granting Service)，它的地位类似于一个普通的服务器，只是它提供的服务是为客户端发放用于和其他服务器认证的票据。</p>\n<p>这样，Kerberos 系统中就有四个角色：认证服务器 (AS)，客户端 (Client)，普通服务器 (Server) 和票据授权服务 (TGS)。这样客户端初次和服务器通信的认证流程分成了以下 6 个步骤：</p>\n<ol>\n<li>\n<p>客户端向 AS 发起请求，请求内容是：客户端的 principal，票据授权服务器的 rincipal</p>\n</li>\n<li>\n<p>AS 收到请求之后，随机生成一个密码 Kc, s (session key), 并生成以下两个票据返回给客户端：</p>\n<ul>\n<li>给客户端的票据，用客户端的密码加密，内容为随机密码，session，tgs_principal</li>\n<li>给 tgs 的票据，用 tgs 的密码加密，内容为随机密码，session，client_principal</li>\n</ul>\n</li>\n<li>\n<p>客户端拿到了第二步中的两个票据后，首先用自己的密码解开票据，得到 Kc、s，然后生成一个 Authenticator，其中主要包括当前时间和 Ts,c 的校验码，并且用 SessionKey Kc,s 加密。之后客户端向 tgs 发起请求，内容包括:</p>\n<ul>\n<li>Authenticator</li>\n<li>给 tgs 的票据同时发给服务器</li>\n<li>server_principal</li>\n</ul>\n</li>\n<li>\n<p>TGS 首先用自己的密码解开票据，拿到 SessionKey Kc,s，然后用 Kc,s 解开 Authenticator，并做如下检查</p>\n<ul>\n<li>检查 Authenticator 中的时间戳是不是在当前时间上下 5 分钟以内，并且检查该时间戳是否首次出现。如果该时间戳不是第一次出现，那说明有人截获了之前客户端发送的内容，进行 Replay 攻击。</li>\n<li>检查 checksum 是否正确</li>\n<li>如果都正确，客户端就通过了认证</li>\n</ul>\n</li>\n<li>\n<p>tgs 生成一个 session key 组装两个票据给客户端</p>\n<ul>\n<li>用客户端和 tgs 的 session key 加密的票据，包含新生成的 session key 和 server_principal</li>\n<li>用服务器的密码加密的票据，包括新生成的 session key 和 client principal</li>\n</ul>\n</li>\n<li>\n<p>客户端收到两个票据后，解开自己的，然后生成一个 Authenticator，发请求给服务器，内容包括</p>\n<ul>\n<li>Authenticator</li>\n<li>给服务器的票据</li>\n</ul>\n</li>\n<li>\n<p>服务器收到请求后，用自己的密码解开票据，得到 session key，然后用 session key 解开 authenticator 对可无端进行验证</p>\n</li>\n<li>\n<p>服务器可以选择返回一个用 session key 加密的之前的是时间戳来完成双向验证</p>\n</li>\n<li>\n<p>客户端通过解开消息，比较发回的时间戳和自己发送的时间戳是否一致，来验证服务器</p>\n</li>\n</ol>\n<h1 id=\"优缺点\"><a class=\"anchor\" href=\"#优缺点\">#</a> 优缺点</h1>\n<h2 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点</h2>\n<ul>\n<li>密码不易被窃听</li>\n<li>密码不在网上传输</li>\n<li>密码猜测更困难</li>\n<li>票据被盗之后难以使用，因为需要配合认证头来使用</li>\n</ul>\n<h3 id=\"9852-缺点\"><a class=\"anchor\" href=\"#9852-缺点\">#</a> 9.8.5.2. 缺点</h3>\n<ul>\n<li>缺乏撤销机制</li>\n<li>引入了复杂的密钥管理</li>\n<li>需要时钟同步</li>\n<li>伸缩性受限</li>\n</ul>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<h2 id=\"规范\"><a class=\"anchor\" href=\"#规范\">#</a> 规范</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE1MTA=\">RFC 1510 The Kerberos Network Authentication Service</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pld2VzL2FydGljbGUvZGV0YWlscy8yMDc5MjAyMQ==\">Kerberos 认证流程详解</span></li>\n</ul>\n<h2 id=\"攻击\"><a class=\"anchor\" href=\"#攻击\">#</a> 攻击</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmxhY2toYXQuY29tL2RvY3MvYXNpYS0xNy9tYXRlcmlhbHMvYXNpYS0xNy1IYXJ0LURlbGVnYXRlLVRvLVRoZS1Ub3AtQWJ1c2luZy1LZXJiZXJvcy1Gb3ItQXJiaXRyYXJ5LUltcGVyc29uYXRpb25zLUFuZC1SQ0Utd3AucGRm\">Delegate to the Top: Abusing Kerberos for arbitrary impersonations and RCE</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvb3BlbnNwZWNzL3dpbmRvd3NfcHJvdG9jb2xzL21zLXNmdS8zYmZmNTg2NC04MTM1LTQwMGUtYmRkOS0zM2I1NTIwNTFkOTQ/cmVkaXJlY3RlZGZyb209TVNETg==\">Kerberos Protocol Extensions: Service for User and Constrained Delegation Protocol</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcHJldmlvdXMtdmVyc2lvbnMvbXNwLW4tcC9mZjY0OTQyOSh2PXBhbmRwLjEwKQ==\">Kerberos Technical Supplement for Windows</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hZHNlY3VyaXR5Lm9yZy8/cD0yMjkz\">Cracking Kerberos TGS Tickets Using Kerberoast – Exploiting Kerberos to Compromise the Active Directory Domain</span></li>\n</ul>\n",
            "tags": [
                "Kerberos认证"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Authentication/Windows%E8%AE%A4%E8%AF%81/",
            "url": "https://mobius-0.github.io/security/WebNote/Authentication/Windows%E8%AE%A4%E8%AF%81/",
            "title": "Windows认证",
            "date_published": "2022-12-06T03:18:09.000Z",
            "content_html": "<h1 id=\"本地用户认证\"><a class=\"anchor\" href=\"#本地用户认证\">#</a> 本地用户认证</h1>\n<p>Windows 在进行本地登录认证时操作系统会使用用户输入的密码作为凭证去与系统中的密码进行对比验证。通过  <code>winlogon.exe</code>  接收用户输入传递至  <code>lsass.exe</code>  进行认证。</p>\n<p><code>winlogon.exe</code>  用于在用户注销、重启、锁屏后显示登录界面。  <code>lsass.exe</code>  用于将明文密码变成 NTLM Hash 的形式与 SAM 数据库比较认证。</p>\n<h1 id=\"sam\"><a class=\"anchor\" href=\"#sam\">#</a> SAM</h1>\n<p>安全帐户管理器 (Security Accounts Manager，SAM) 是 Windows 操作系统管理用户帐户的安全所使用的一种机制。用来存储 Windows 操作系统密码的数据库文件为了避免明文密码泄漏 SAM 文件中保存的是明文密码在经过一系列算法处理过的 Hash 值被保存的 Hash 分为 LM Hash、NTLM Hash。当用户进行身份认证时会将输入的 Hash 值与 SAM 文件中保存的 Hash 值进行对比。</p>\n<p>SAM 文件保存于  <code>%SystemRoot%\\system32\\config\\sam</code>  中，在注册表中保存在  <code>HKEY_LOCAL_MACHINE\\SAM\\SAM</code>  ，  <code>HKEY_LOCAL_MACHINE\\SECURITY\\SAM</code>  。 在正常情况下 SAM 文件处于锁定状态不可直接访问、复制、移动仅有 system 用户权限才可以读写该文件。</p>\n<h1 id=\"密码破解\"><a class=\"anchor\" href=\"#密码破解\">#</a> 密码破解</h1>\n<ul>\n<li>通过物理接触主机、启动其他操作系统来获取 Windows 分区上的  <code>%SystemRoot%\\system32\\config\\sam</code>  文件</li>\n<li>获取  <code>%SystemRoot%\\repair\\sam._</code>  文件。</li>\n<li>使用工具从注册表中导出 SAM 散列值</li>\n<li>从网络中嗅探分析 SMB 报文，从中获取密码散列</li>\n</ul>\n<h1 id=\"spnego\"><a class=\"anchor\" href=\"#spnego\">#</a> SPNEGO</h1>\n<p>SPNEGO (SPNEGO: Simple and Protected GSS-API Negotiation) 是微软提供的一种使用 GSS-API 认证机制的安全协议，用于使 Webserver 共享 Windows Credentials，它扩展了 Kerberos。</p>\n",
            "tags": [
                "认证",
                "Windows"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Authentication/JWT/",
            "url": "https://mobius-0.github.io/security/WebNote/Authentication/JWT/",
            "title": "JWT",
            "date_published": "2022-12-06T02:55:21.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519). 该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p>\n<h1 id=\"构成\"><a class=\"anchor\" href=\"#构成\">#</a> 构成</h1>\n<p>分为三个部分，分别为头部（Header）、声明（Claims，也可以称为负载 Payload）、证书（Signature），三个部分以英文句号 <code>.</code>  隔开。其中 header 是声明的类型和加密使用的算法。下面是一个用 HS256 生成 JWT 的代码例子： <code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)</code></p>\n<p>头部（Header）:</p>\n<pre><code>&#123;\n  &quot;alg&quot;:&quot;HS256&quot;,\n  &quot;typ&quot;:&quot;JWT&quot;\n&#125;\n</code></pre>\n<blockquote>\n<p>alg：是说明这个 JWT 的签名使用的算法的参数，常见值用 HS256（默认），HS512 等，也可以为 None。HS256 表示 HMAC SHA256。<br />\ntyp：说明这个 token 的类型为 JWT</p>\n</blockquote>\n<p>声明（Claims）:</p>\n<pre><code>&#123;\n  &quot;exp&quot;: 1416471934,\n  &quot;user_name&quot;: &quot;user&quot;,\n  &quot;scope&quot;: [\n    &quot;read&quot;,\n    &quot;write&quot;\n  ],\n  &quot;authorities&quot;: [\n    &quot;ROLE_ADMIN&quot;,\n    &quot;ROLE_USER&quot;\n  ],\n  &quot;jti&quot;: &quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;,\n  &quot;client_id&quot;: &quot;my-client-with-secret&quot;\n&#125;\n</code></pre>\n<blockquote>\n<p>JWT 固定参数有：<br />\niss：发行人<br />\n exp：到期时间<br />\n sub：主题<br />\n aud：用户<br />\n nbf：在此之前不可用<br />\n iat：发布时间<br />\n jti：JWT ID 用于标识该 JWT</p>\n</blockquote>\n<p>签名（Signature）:<br />\n 服务器有一个不会发送给客户端的密码（secret），用头部中指定的算法对头部和声明的内容用此密码进行加密，生成的字符串就是 JWT 的签名。</p>\n<h1 id=\"安全问题\"><a class=\"anchor\" href=\"#安全问题\">#</a> 安全问题</h1>\n<h2 id=\"header部分\"><a class=\"anchor\" href=\"#header部分\">#</a> Header 部分</h2>\n<ul>\n<li>是否支持修改算法为 none / 对称加密算法</li>\n<li>删除签名</li>\n<li>插入错误信息</li>\n<li>直接在 header 中加入新的公钥</li>\n<li>kid 字段是否有 SQL 注入 / 命令注入 / 目录遍历</li>\n<li>结合业务功能通过 kid 直接下载对应公私钥</li>\n<li>是否强制使用白名单上的加密算法</li>\n<li>JWKS 劫持</li>\n<li>JKU (JWK Set URL) / X5U (X.509 URL) 注入</li>\n</ul>\n<h2 id=\"payload部分\"><a class=\"anchor\" href=\"#payload部分\">#</a> Payload 部分</h2>\n<ul>\n<li>其中是否存在敏感信息</li>\n<li>检查过期策略，比如  <code>exp</code>  ,  <code>iat</code></li>\n</ul>\n<h2 id=\"signature部分\"><a class=\"anchor\" href=\"#signature部分\">#</a> Signature 部分</h2>\n<ul>\n<li>检查是否强制检查签名</li>\n<li>密钥是否可以爆破</li>\n<li>是否可以通过其他方式拿到密钥</li>\n</ul>\n<h2 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h2>\n<ul>\n<li>重放</li>\n<li>通过匹配校验的时间做时间攻击</li>\n<li>修改算法 RS256 为 HS256</li>\n<li>弱密钥破解</li>\n</ul>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdXRoMC5jb20vYmxvZy8=\">Critical vulnerabilities in JSON Web Token libraries</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qd3QuaW8vI2VuY29kZWQtand0\">JWT CODE</span></li>\n</ul>\n",
            "tags": [
                "JWT"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Authentication/SSO/",
            "url": "https://mobius-0.github.io/security/WebNote/Authentication/SSO/",
            "title": "SSO",
            "date_published": "2022-12-06T02:51:21.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>单点登录 (SingleSignOn，SSO) 指一个用户可以通过单一的 ID 和凭证（密码）访问多个相关但彼此独立的系统。</p>\n<h2 id=\"常见流程\"><a class=\"anchor\" href=\"#常见流程\">#</a> 常见流程</h2>\n<ol>\n<li>用户 (User) 向服务提供商 (Service Provider) 发起请求</li>\n<li>SP 重定向 User 至 SSO 身份校验服务 (Identity Provider)</li>\n<li>User 通过 IP 登录</li>\n<li>IP 返回凭证给 User</li>\n<li>User 将凭证发给 SP</li>\n<li>SP 返回受保护的资源给用户</li>\n</ol>\n<p>其中凭证要有以下属性</p>\n<ul>\n<li>\n<p>签发者的签名</p>\n</li>\n<li>\n<p>凭证的身份</p>\n</li>\n<li>\n<p>使用的时间</p>\n<ul>\n<li>过期时间</li>\n<li>生效时间</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"可能的攻击漏洞\"><a class=\"anchor\" href=\"#可能的攻击漏洞\">#</a> 可能的攻击 / 漏洞</h1>\n<h2 id=\"信息泄漏\"><a class=\"anchor\" href=\"#信息泄漏\">#</a> 信息泄漏</h2>\n<p>若 SP 和 IP 之前使用明文传输信息，可能会被窃取。</p>\n<h2 id=\"伪造\"><a class=\"anchor\" href=\"#伪造\">#</a> 伪造</h2>\n<p>如果在通信过程中没有对关键信息进行签名，容易被伪造。</p>\n",
            "tags": [
                "认证",
                "单点登录"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Authentication/%E5%A4%9A%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81/",
            "url": "https://mobius-0.github.io/security/WebNote/Authentication/%E5%A4%9A%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81/",
            "title": "多因子认证",
            "date_published": "2022-12-06T02:49:21.000Z",
            "content_html": "<p>多因子认证是在单因子认证不足以保证安全性时使用的方法，通常会引入多种方式对用户身份进行验证。身份验证方法可以基于知识的认证，即密码；也可以基于物品的认证，例如硬件密钥；也可以是基于特征的认证，例如包含指纹在内的生物特征等。</p>\n<p>具体来说，目前常用的生物特征有：指纹、人脸、虹膜、静脉、声纹、体态等。常用的评价指标主要是速度（注册、识别使用的时间），精确度（假阳性、假阴性）等。</p>\n",
            "tags": [
                "认证"
            ]
        }
    ]
}