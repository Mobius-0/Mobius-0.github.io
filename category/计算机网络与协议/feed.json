{
    "version": "https://jsonfeed.org/version/1",
    "title": "Khala • All posts by \"计算机网络与协议\" category",
    "description": "GLHF",
    "home_page_url": "https://mobius-0.github.io",
    "items": [
        {
            "id": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/WiFi/",
            "url": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/WiFi/",
            "title": "WiFi",
            "date_published": "2022-11-26T08:48:19.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>Wi-Fi 又称 “无线热点” 或 “无线网络”，是 Wi-Fi 联盟的商标，一个基于 IEEE 802.11 标准的无线局域网技术。</p>\n<h1 id=\"攻击\"><a class=\"anchor\" href=\"#攻击\">#</a> 攻击</h1>\n<h2 id=\"暴力破解\"><a class=\"anchor\" href=\"#暴力破解\">#</a> 暴力破解</h2>\n<p>WiFi 密码是基于预置的秘钥，可以通过抓取报文的方式在本地快速的批量进行密码爆破尝试。</p>\n<h2 id=\"伪造热点\"><a class=\"anchor\" href=\"#伪造热点\">#</a> 伪造热点</h2>\n<p>AP 可以动态的广播自己，客户也可以主动发送探针请求。可以伪造 AP 发送对探针请求的响应包，来让客户端错误的识别。</p>\n<h2 id=\"秘钥重装攻击\"><a class=\"anchor\" href=\"#秘钥重装攻击\">#</a> 秘钥重装攻击</h2>\n<p>该漏洞由 Vanhoef 发现。Wi-Fi 在握手时双方会更新秘钥，该攻击通过重放握手信息，令客户端重新安装相同的秘钥。</p>\n<h2 id=\"dragonblood\"><a class=\"anchor\" href=\"#dragonblood\">#</a> Dragonblood</h2>\n<p>最新版的 WPA3 标准在实现上存在一些问题，同样由 Vanhoef 发现。包含拒绝服务攻击、降级攻击、侧信道泄露等。</p>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2ktZmkub3JnLw==\">Wi-Fi Alliance</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYXBlcnMubWF0aHl2YW5ob2VmLmNvbS9kcmFnb25ibG9vZC5wZGY=\">Dragonblood</span> : Analyzing the Dragonfly Handshake of WPA3 and EAP-pwd</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYXBlcnMubWF0aHl2YW5ob2VmLmNvbS9ub3Jkc2VjMjAxOS5wZGY=\">Improving Privacy through Fast Passive Wi-Fi Scanning</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYXBlcnMubWF0aHl2YW5ob2VmLmNvbS9hc2lhY2NzMjAxOS5wZGY=\">Practical Side-Channel Attacks against WPA-TKIP</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYXBlcnMubWF0aHl2YW5ob2VmLmNvbS9ibGFja2hhdC1ldTIwMTcucGRm\">Key Reinstallation Attacks: Breaking the WPA2 Protocol</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc2NjQ=\">RFC 7664 Dragonfly Key Exchange</span></li>\n</ul>\n",
            "tags": [
                "计算机网络",
                "WiFi"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/IPSec/",
            "url": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/IPSec/",
            "title": "IPSec",
            "date_published": "2022-11-26T08:47:59.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>IPsec（IP Security）是 IETF 制定的三层隧道加密协议，它为 Internet 上传输的数据提供了高质量的、可互操作的、基于密码学的安全保证。特定的通信方之间在 IP 层通过加密与数据源认证等方式，提供了以下的安全服务：</p>\n<ul>\n<li>数据机密性（Confidentiality）：IPsec 发送方在通过网络传输包前对包进行加密。</li>\n<li>数据完整性（Data Integrity）：IPsec 接收方对发送方发送来的包进行认证，以确保数据在传输过程中没有被篡改。</li>\n<li>数据来源认证（Data Authentication）：IPsec 在接收端可以认证发送 IPsec 报文的发送端是否合法。</li>\n<li>防重放（Anti-Replay）：IPsec 接收方可检测并拒绝接收过时或重复的报文。</li>\n</ul>\n<h1 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点</h1>\n<p>IPsec 具有以下优点：</p>\n<ul>\n<li>支持 IKE（Internet Key Exchange，因特网密钥交换），可实现密钥的自动协商功能，减少了密钥协商的开销。可以通过 IKE 建立和维护 SA 的服务，简化了 IPsec 的使用和管理。</li>\n<li>所有使用 IP 协议进行数据传输的应用系统和服务都可以使用 IPsec，而不必对这些应用系统和服务本身做任何修改。</li>\n<li>对数据的加密是以数据包为单位的，而不是以整个数据流为单位，这不仅灵活而且有助于进一步提高 IP 数据包的安全性，可以有效防范网络攻击。</li>\n</ul>\n<h1 id=\"构成\"><a class=\"anchor\" href=\"#构成\">#</a> 构成</h1>\n<p>IPsec 由四部分内容构成：</p>\n<ul>\n<li>负责密钥管理的 Internet 密钥交换协议 IKE（Internet Key Exchange Protocol）</li>\n<li>负责将安全服务与使用该服务的通信流相联系的安全关联 SA（Security Associations）</li>\n<li>直接操作数据包的认证头协议 AH（IP Authentication Header）和安全载荷协议 ESP（IP Encapsulating Security Payload）</li>\n<li>若干用于加密和认证的算法</li>\n</ul>\n<h1 id=\"安全联盟security-associationsa\"><a class=\"anchor\" href=\"#安全联盟security-associationsa\">#</a> 安全联盟（Security Association，SA）</h1>\n<p>IPsec 在两个端点之间提供安全通信，端点被称为 IPsec 对等体。</p>\n<p>SA 是 IPsec 的基础，也是 IPsec 的本质。SA 是通信对等体间对某些要素的约定，例如，使用哪种协议（AH、ESP 还是两者结合使用）、协议的封装模式（传输模式和隧道模式）、加密算法（DES、3DES 和 AES）、特定流中保护数据的共享密钥以及密钥的生存周期等。建立 SA 的方式有手工配置和 IKE 自动协商两种。</p>\n<p>SA 是单向的，在两个对等体之间的双向通信，最少需要两个 SA 来分别对两个方向的数据流进行安全保护。同时，如果两个对等体希望同时使用 AH 和 ESP 来进行安全通信，则每个对等体都会针对每一种协议来构建一个独立的 SA。</p>\n<p>SA 由一个三元组来唯一标识，这个三元组包括 SPI（Security Parameter Index，安全参数索引）、目的 IP 地址、安全协议号（AH 或 ESP）。</p>\n<p>SPI 是用于唯一标识 SA 的一个 32 比特数值，它在 AH 和 ESP 头中传输。在手工配置 SA 时，需要手工指定 SPI 的取值。使用 IKE 协商产生 SA 时，SPI 将随机生成。</p>\n<h1 id=\"ike\"><a class=\"anchor\" href=\"#ike\">#</a> IKE</h1>\n<p>IKE（RFC2407，RFC2408、RFC2409）属于一种混合型协议，由 Internet 安全关联和密钥管理协议（ISAKMP）和两种密钥交换协议 OAKLEY 与 SKEME 组成。IKE 创建在由 ISAKMP 定义的框架上，沿用了 OAKLEY 的密钥交换模式以及 SKEME 的共享和密钥更新技术，还定义了它自己的两种密钥交换方式。</p>\n<p>IKE 使用了两个阶段的 ISAKMP：</p>\n<p>第一阶段，协商创建一个通信信道（IKE SA），并对该信道进行验证，为双方进一步的 IKE 通信提供机密性、消息完整性以及消息源验证服务； 第二阶段，使用已建立的 IKE SA 建立 IPsec SA（V2 中叫 Child SA）。</p>\n",
            "tags": [
                "计算机网络",
                "IPSec",
                "VPN"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/SSL%E3%80%81TLS/",
            "url": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/SSL%E3%80%81TLS/",
            "title": "SSL/TLS",
            "date_published": "2022-11-26T08:42:19.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>SSL 全称是 Secure Sockets Layer，安全套接字层，它是由网景公司 (Netscape) 在 1994 年时设计，主要用于 Web 的安全传输协议，目的是为网络通信提供机密性、认证性及数据完整性保障。如今，SSL 已经成为互联网保密通信的工业标准。</p>\n<p>SSL 最初的几个版本 (SSL 1.0、SSL2.0、SSL 3.0) 由网景公司设计和维护，从 3.1 版本开始，SSL 协议由因特网工程任务小组 (IETF) 正式接管，并更名为 TLS (Transport Layer Security)，发展至今已有 TLS 1.0、TLS1.1、TLS1.2、TLS1.3 这几个版本。</p>\n<p>如 TLS 名字所说，SSL/TLS 协议仅保障传输层安全。同时，由于协议自身特性 (数字证书机制)，SSL/TLS 不能被用于保护多跳 (multi-hop) 端到端通信，而只能保护点到点通信。</p>\n<p>SSL/TLS 协议能够提供的安全目标主要包括如下几个：</p>\n<ul>\n<li>认证性：借助数字证书认证服务端端和客户端身份，防止身份伪造</li>\n<li>机密性：借助加密防止第三方窃听</li>\n<li>完整性：借助消息认证码 (MAC) 保障数据完整性，防止消息篡改</li>\n<li>重放保护：通过使用隐式序列号防止重放攻击</li>\n</ul>\n<p>为了实现这些安全目标，SSL/TLS 协议被设计为一个两阶段协议，分为握手阶段和应用阶段：</p>\n<p>握手阶段也称协商阶段，在这一阶段，客户端和服务端端会认证对方身份 (依赖于 PKI 体系，利用数字证书进行身份认证)，并协商通信中使用的安全参数、密码套件以及 MasterSecret。后续通信使用的所有密钥都是通过 MasterSecret 生成。 在握手阶段完成后，进入应用阶段。在应用阶段通信双方使用握手阶段协商好的密钥进行安全通信。</p>\n<h1 id=\"协议\"><a class=\"anchor\" href=\"#协议\">#</a> 协议</h1>\n<p>TLS 包含几个子协议，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</p>\n<h2 id=\"记录协议\"><a class=\"anchor\" href=\"#记录协议\">#</a> 记录协议</h2>\n<p>记录协议 (Record Protocol) 规定了 TLS 收发数据的基本单位记录 (record)。</p>\n<h2 id=\"警报协议\"><a class=\"anchor\" href=\"#警报协议\">#</a> 警报协议</h2>\n<p>警报协议 (Alert Protocol) 用于提示协议交互过程出现错误。</p>\n<h2 id=\"握手协议\"><a class=\"anchor\" href=\"#握手协议\">#</a> 握手协议</h2>\n<p>握手协议 (Handshake Protocol) 是 TLS 里最复杂的子协议，在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</p>\n<h2 id=\"变更密码规范协议\"><a class=\"anchor\" href=\"#变更密码规范协议\">#</a> 变更密码规范协议</h2>\n<p>变更密码规范协议 (Change Cipher Spec Protocol) 是一个 “通知”，告诉对方，后续的数据都将使用加密保护。</p>\n<h1 id=\"交互过程\"><a class=\"anchor\" href=\"#交互过程\">#</a> 交互过程</h1>\n<h2 id=\"client-hello\"><a class=\"anchor\" href=\"#client-hello\">#</a> Client Hello</h2>\n<p>Client Hello 由客户端发送，内容包括客户端的一个 Unix 时间戳 (GMT Unix Time)、一些随机的字节 (Random Bytes)，还包括了客户端接受的算法类型 (Cipher Suites)。</p>\n<h2 id=\"server-hello\"><a class=\"anchor\" href=\"#server-hello\">#</a> Server Hello</h2>\n<p>Server Hello 由服务端发送，内容包括服务端支持的算法类型、GMT Unix Time 以及 Random Bytes。</p>\n<h2 id=\"certificate\"><a class=\"anchor\" href=\"#certificate\">#</a> Certificate</h2>\n<p>由服务端或者客户端发送，发送方会会将自己的数字证书发送给接收方，由接收方进行证书验证，如果不通过的话，接收方会中断握手的过程。一般跟在 Client / Server Hello 报文之后。</p>\n<h2 id=\"server-key-exchange\"><a class=\"anchor\" href=\"#server-key-exchange\">#</a> Server Key Exchange</h2>\n<p>由服务端发送，将自己的公钥参数传输给了客户端，一般也和 Server Hello 与 Certificate 在一个 TCP 报文中。</p>\n<h2 id=\"server-hello-done\"><a class=\"anchor\" href=\"#server-hello-done\">#</a> Server Hello Done</h2>\n<p>服务端发送，一般也和 Server Hello、Certificate 和 Server Key Exchange 在一个 TCP 报文中。</p>\n<h2 id=\"client-key-exchange\"><a class=\"anchor\" href=\"#client-key-exchange\">#</a> Client Key Exchange</h2>\n<p>客户端发送，向服务端发送自己的公钥参数，与服务端协商密钥。</p>\n<h2 id=\"change-cipher-spec\"><a class=\"anchor\" href=\"#change-cipher-spec\">#</a> Change Cipher Spec</h2>\n<p>客户端或者服务端发送，紧跟着 Key Exchange 发送，代表自己生成了新的密钥，通知对方以后将更换密钥，使用新的密钥进行通信。</p>\n<h2 id=\"encrypted-handshake-message\"><a class=\"anchor\" href=\"#encrypted-handshake-message\">#</a> Encrypted Handshake Message</h2>\n<p>客户端或者服务端发送，紧跟着 Key Exchange 发送。进行测试，一方用自己的刚刚生成的密钥加密一段固定的消息发送给对方，如果密钥协商正确无误的话，对方可以正确解密。</p>\n<h2 id=\"new-session-ticket\"><a class=\"anchor\" href=\"#new-session-ticket\">#</a> New Session Ticket</h2>\n<p>服务端发送，表示发起会话，在一段时间之内 (超时时间到来之前)，双方都以刚刚交换的密钥进行通信。从这以后，加密通信正式开始。</p>\n<h2 id=\"application-data\"><a class=\"anchor\" href=\"#application-data\">#</a> Application Data</h2>\n<p>使用密钥交换协议协商出来的密钥加密的应用层的数据。</p>\n<h2 id=\"encrypted-alert\"><a class=\"anchor\" href=\"#encrypted-alert\">#</a> Encrypted Alert</h2>\n<p>客户端或服务端发送，意味着加密通信因为某些原因需要中断，警告对方不要再发送敏感的数据。</p>\n<h1 id=\"版本更新内容\"><a class=\"anchor\" href=\"#版本更新内容\">#</a> 版本更新内容</h1>\n<h2 id=\"tls-13\"><a class=\"anchor\" href=\"#tls-13\">#</a> TLS 1.3</h2>\n<ul>\n<li>\n<p>引入了 PSK 作为新的密钥协商机制</p>\n</li>\n<li>\n<p>支持 0-RTT 模式，以安全性降低为代价，在建立连接时节省了往返时间</p>\n</li>\n<li>\n<p>ServerHello 之后的所有握手消息采取了加密操作，可见明文减少</p>\n</li>\n<li>\n<p>不再允许对加密报文进行压缩、不再允许双方发起重协商</p>\n</li>\n<li>\n<p>DSA 证书不再允许在 TLS 1.3 中使用</p>\n</li>\n<li>\n<p>删除不安全的密码算法</p>\n<ul>\n<li>RSA 密钥传输 - 不支持前向安全性</li>\n<li>CBC 模式密码 - 易受 BEAST 和 Lucky 13 攻击</li>\n<li>RC4 流密码 - 在 HTTPS 中使用并不安全</li>\n<li>SHA-1 哈希函数 - 建议以 SHA-2 取而代之</li>\n<li>任意 Diffie-Hellman 组 - CVE-2016-0701 漏洞</li>\n<li>输出密码 - 易受 FREAK 和 LogJam 攻击</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"子协议\"><a class=\"anchor\" href=\"#子协议\">#</a> 子协议</h1>\n<p>SSL/TLS 协议有一个高度模块化的架构，分为很多子协议，主要是：</p>\n<ul>\n<li>\n<p>Handshake 协议</p>\n<ul>\n<li>包括协商安全参数和密码套件、服务端身份认证 (客户端身份认证可选)、密钥交换</li>\n</ul>\n</li>\n<li>\n<p>ChangeCipherSpec 协议</p>\n<ul>\n<li>一条消息表明握手协议已经完成</li>\n</ul>\n</li>\n<li>\n<p>Alert 协议</p>\n<ul>\n<li>对握手协议中一些异常的错误提醒，分为 fatal 和 warning 两个级别，fatal 类型的错误会直接中断 SSL 链接，而 warning 级别的错误 SSL 链接仍可继续，只是会给出错误警告</li>\n</ul>\n</li>\n<li>\n<p>Record 协议</p>\n<ul>\n<li>包括对消息的分段、压缩、消息认证和完整性保护、加密等</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<h2 id=\"rfc\"><a class=\"anchor\" href=\"#rfc\">#</a> RFC</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIyNDY=\">RFC 2246 The TLS Protocol Version 1.0</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQzNDY=\">RFC 4346 The Transport Layer Security (TLS) Protocol Version 1.1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUyNDY=\">RFC 5246 The Transport Layer Security (TLS) Protocol Version 1.2</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxMDE=\">RFC 6101 The Secure Sockets Layer (SSL) Protocol Version 3.0</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxNzY=\">RFC 6176 Prohibiting Secure Sockets Layer (SSL) Version 2.0</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1Njg=\">RFC 7568 Deprecating Secure Sockets Layer Version 3.0</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzg0NDY=\">RFC 8446 The Transport Layer Security (TLS) Protocol Version 1.3</span></li>\n</ul>\n<h2 id=\"document\"><a class=\"anchor\" href=\"#document\">#</a> Document</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJhbnNwb3J0X0xheWVyX1NlY3VyaXR5\">Wikipedia Transport Layer Security</span></li>\n</ul>\n",
            "tags": [
                "计算机网络",
                "SSL",
                "TLS"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/mail/",
            "url": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/mail/",
            "title": "邮件协议簇",
            "date_published": "2022-11-25T07:58:31.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<h2 id=\"smtp\"><a class=\"anchor\" href=\"#smtp\">#</a> SMTP</h2>\n<p>SMTP (Simple Mail Transfer Protocol) 是一种电子邮件传输的协议，是一组用于从源地址到目的地址传输邮件的规范。不启用 SSL 时端口号为 25，启用 SSL 时端口号多为 465 或 994。</p>\n<h2 id=\"pop3\"><a class=\"anchor\" href=\"#pop3\">#</a> POP3</h2>\n<p>POP3 (Post Office Protocol 3) 用于支持使用客户端远程管理在服务器上的电子邮件。不启用 SSL 时端口号为 110，启用 SSL 时端口号多为 995。</p>\n<h2 id=\"imap\"><a class=\"anchor\" href=\"#imap\">#</a> IMAP</h2>\n<p>IMAP (Internet Mail Access Protocol)，即交互式邮件存取协议，它是跟 POP3 类似邮件访问标准协议之一。不同的是，开启了 IMAP 后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。不启用 SSL 时端口号为 143，启用 SSL 时端口号多为 993。</p>\n<h1 id=\"防护策略\"><a class=\"anchor\" href=\"#防护策略\">#</a> 防护策略</h1>\n<h2 id=\"spf\"><a class=\"anchor\" href=\"#spf\">#</a> SPF</h2>\n<p>发件人策略框架 (Sender Policy Framework, SPF) 是一套电子邮件认证机制，用于确认电子邮件是否由网域授权的邮件服务器寄出，防止有人伪冒身份网络钓鱼或寄出垃圾邮件。SPF 允许管理员设定一个 DNS TXT 记录或 SPF 记录设定发送邮件服务器的 IP 范围，如有任何邮件并非从上述指明授权的 IP 地址寄出，则很可能该邮件并非确实由真正的寄件者寄出。</p>\n<h2 id=\"dkim\"><a class=\"anchor\" href=\"#dkim\">#</a> DKIM</h2>\n<p>域名密钥识别邮件 (DomainKeys Identified Mail, DKIM) 是一种检测电子邮件发件人地址伪造的方法。发送方会在邮件的头中插入 DKIM-Signature，收件方通过查询 DNS 记录中的公钥来验证发件人的信息。</p>\n<h2 id=\"dmarc\"><a class=\"anchor\" href=\"#dmarc\">#</a> DMARC</h2>\n<p>基于网域的消息认证、报告和一致性 (Domain-based Message Authentication, Reporting and Conformance, DMARC) 是电子邮件身份验证协议，用于解决在邮件栏中显示的域名和验证的域名不一致的问题。要通过 DMARC 检查，必须通过 SPF 或 / 和 DKIM 的身份验证，且需要标头地址中的域名必须与经过身份验证的域名一致。</p>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<h2 id=\"rfc\"><a class=\"anchor\" href=\"#rfc\">#</a> RFC</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ0MDg=\">RFC 4408 Sender Policy Framework (SPF) for Authorizing Use of Domains in E-Mail, Version 1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYzNzY=\">RFC 6376 DomainKeys Identified Mail (DKIM) Signatures</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMDg=\">RFC 7208 Sender Policy Framework (SPF) for Authorizing Use of Domains in Email, Version 1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc0ODk=\">RFC 7489 Domain-based Message Authentication, Reporting, and Conformance (DMARC)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgzMDE=\">RFC 8301 Cryptographic Algorithm and Key Usage Update to DomainKeys Identified Mail (DKIM)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzg0NjM=\">RFC 8463 A New Cryptographic Signature Method for DomainKeys Identified Mail (DKIM)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzg2MTY=\">RFC 8616 Email Authentication for Internationalized Mail</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzg2MTE=\">RFC 8611 Mail</span></li>\n</ul>\n<h2 id=\"相关文档\"><a class=\"anchor\" href=\"#相关文档\">#</a> 相关文档</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VuZGVyX1BvbGljeV9GcmFtZXdvcms=\">Sender Policy Framework wikipedia</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG9tYWluS2V5c19JZGVudGlmaWVkX01haWw=\">DomainKeys Identified Mail wikipedia</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRE1BUkM=\">DMARC wikipedia</span></li>\n</ul>\n<h2 id=\"研究文章\"><a class=\"anchor\" href=\"#研究文章\">#</a> 研究文章</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2kuYmxhY2toYXQuY29tL1VTQS0yMC9UaHVyc2RheS91cy0yMC1DaGVuLVlvdS1IYXZlLU5vLUlkZWEtV2hvLVNlbnQtVGhhdC1FbWFpbC0xOC1BdHRhY2tzLU9uLUVtYWlsLVNlbmRlci1BdXRoZW50aWNhdGlvbi13cC5wZGY=\">Composition Kills:A Case Study of Email Sender Authentication</span></li>\n</ul>\n",
            "tags": [
                "邮件",
                "网络协议"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/HTTP/",
            "url": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/HTTP/",
            "title": "HTTP协议簇",
            "date_published": "2022-11-25T03:05:41.000Z",
            "content_html": "<h1 id=\"http标准\"><a class=\"anchor\" href=\"#http标准\">#</a> HTTP 标准</h1>\n<h2 id=\"报文格式\"><a class=\"anchor\" href=\"#报文格式\">#</a> 报文格式</h2>\n<h3 id=\"请求报文格式\"><a class=\"anchor\" href=\"#请求报文格式\">#</a> 请求报文格式</h3>\n<figure class=\"highlight http\"><figcaption data-lang=\"HTTP\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>&lt;method>&lt;request-URL>&lt;version></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>&lt;headers></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>&lt;entity-body></pre></td></tr></table></figure><h3 id=\"响应报文格式\"><a class=\"anchor\" href=\"#响应报文格式\">#</a> 响应报文格式</h3>\n<figure class=\"highlight http\"><figcaption data-lang=\"HTTP\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>&lt;version>&lt;status>&lt;reason-phrase></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>&lt;headers></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>&lt;entity-body></pre></td></tr></table></figure><h3 id=\"字段解释\"><a class=\"anchor\" href=\"#字段解释\">#</a> 字段解释</h3>\n<ul>\n<li>method\n<ul>\n<li>HTTP 动词</li>\n<li>常见方法：HEAD / GET / POST / PUT / DELETE / PATCH / OPTIONS / TRACE</li>\n<li>扩展方法：LOCK / MKCOL / COPY / MOVE</li>\n</ul>\n</li>\n<li>version\n<ul>\n<li>报文使用的 HTTP 版本</li>\n<li>格式为 HTTP/&lt;major&gt;.&lt;minor&gt;</li>\n</ul>\n</li>\n<li>url\n<ul>\n<li><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"请求头列表\"><a class=\"anchor\" href=\"#请求头列表\">#</a> 请求头列表</h2>\n<ul>\n<li>Accept\n<ul>\n<li>指定客户端能够接收的内容类型</li>\n<li>Accept: text/plain, text/html</li>\n</ul>\n</li>\n<li>Accept-Charset\n<ul>\n<li>浏览器可以接受的字符编码集</li>\n<li>Accept-Charset: iso-8859-5</li>\n</ul>\n</li>\n<li>Accept-Encoding\n<ul>\n<li>指定浏览器可以支持的 web 服务器返回内容压缩编码类型</li>\n<li>Accept-Encoding: compress, gzip</li>\n</ul>\n</li>\n<li>Accept-Language\n<ul>\n<li>浏览器可接受的语言</li>\n<li>Accept-Language: en,zh</li>\n</ul>\n</li>\n<li>Accept-Ranges\n<ul>\n<li>可以请求网页实体的一个或者多个子范围字段</li>\n<li>Accept-Ranges: bytes</li>\n</ul>\n</li>\n<li>Authorization\n<ul>\n<li>HTTP 授权的授权证书</li>\n<li>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</li>\n</ul>\n</li>\n<li>Cache-Control\n<ul>\n<li>指定请求和响应遵循的缓存机制 Cache-Control: no-cache</li>\n</ul>\n</li>\n<li>Connection\n<ul>\n<li>表示是否需要持久连接 // HTTP 1.1 默认进行持久连接</li>\n<li>Connection: close</li>\n</ul>\n</li>\n<li>Cookie\n<ul>\n<li>HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器</li>\n<li>Cookie: role=admin;ssid=1</li>\n</ul>\n</li>\n<li>Content-Length\n<ul>\n<li>请求的内容长度</li>\n<li>Content-Length: 348</li>\n</ul>\n</li>\n<li>Content-Type\n<ul>\n<li>请求的与实体对应的 MIME 信息</li>\n<li>Content-Type: application/x-www-form-urlencoded</li>\n</ul>\n</li>\n<li>Date\n<ul>\n<li>请求发送的日期和时间</li>\n<li>Date: Tue, 15 Nov 2010 08:12:31 GMT</li>\n</ul>\n</li>\n<li>Expect\n<ul>\n<li>请求的特定的服务器行为</li>\n<li>Expect: 100-continue</li>\n</ul>\n</li>\n<li>From\n<ul>\n<li>发出请求的用户的</li>\n<li>EmailFrom: <span class=\"exturl\" data-url=\"bWFpbHRvOnVzZXJAZW1haWwuY29t\">user@email.com</span></li>\n</ul>\n</li>\n<li>Host\n<ul>\n<li>指定请求的服务器的域名和端口号</li>\n<li>Host: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5naXRodWIuY29t\">www.github.com</span></li>\n</ul>\n</li>\n<li>If-Match\n<ul>\n<li>只有请求内容与实体相匹配才有效</li>\n<li>If-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</li>\n</ul>\n</li>\n<li>If-Modified-Since\n<ul>\n<li>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回 304 代码</li>\n<li>If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT</li>\n</ul>\n</li>\n<li>If-None-Match\n<ul>\n<li>如果内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改变</li>\n<li>If-None-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</li>\n</ul>\n</li>\n<li>If-Range\n<ul>\n<li>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为 Etag</li>\n<li>If-Range: &quot;737060cd8c284d8af7ad3082f209582d&quot;</li>\n</ul>\n</li>\n<li>If-Unmodified-Since\n<ul>\n<li>只在实体在指定时间之后未被修改才请求成功</li>\n<li>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</li>\n</ul>\n</li>\n<li>Max-Forwards\n<ul>\n<li>限制信息通过代理和网关传送的时间</li>\n<li>Max-Forwards: 10</li>\n</ul>\n</li>\n<li>Pragma\n<ul>\n<li>用来包含实现特定的指令</li>\n<li>Pragma: no-cache</li>\n</ul>\n</li>\n<li>Proxy-Authorization\n<ul>\n<li>连接到代理的授权证书</li>\n<li>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</li>\n</ul>\n</li>\n<li>Range\n<ul>\n<li>只请求实体的一部分，指定范围</li>\n<li>Range: bytes=500-999</li>\n</ul>\n</li>\n<li>Referer\n<ul>\n<li>先前网页的地址，当前请求网页紧随其后，即来路</li>\n<li>Referer: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvNzEuaHRtbA==\">http://www.zcmhi.com/archives/71.html</span></li>\n</ul>\n</li>\n<li>TE\n<ul>\n<li>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</li>\n<li>TE: trailers,deflate;q=0.5</li>\n</ul>\n</li>\n<li>Upgrade\n<ul>\n<li>向服务器指定某种传输协议以便服务器进行转换（如果支持）</li>\n<li>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</li>\n</ul>\n</li>\n<li>User-Agent\n<ul>\n<li>User-Agent 的内容包含发出请求的用户信息</li>\n<li>User-Agent: Mozilla/5.0 (Linux; X11)</li>\n</ul>\n</li>\n<li>Via\n<ul>\n<li>通知中间网关或代理服务器地址，通信协议</li>\n<li>Via: 1.0 fred, 1.1 <span class=\"exturl\" data-url=\"aHR0cDovL25vd2hlcmUuY29t\">nowhere.com</span> (Apache/1.1)</li>\n</ul>\n</li>\n<li>Warning\n<ul>\n<li>关于消息实体的警告信息</li>\n<li>Warn: 199 Miscellaneous warning</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"响应头列表\"><a class=\"anchor\" href=\"#响应头列表\">#</a> 响应头列表</h2>\n<ul>\n<li>Accept-Ranges\n<ul>\n<li>表明服务器是否支持指定范围请求及哪种类型的分段请求</li>\n<li>Accept-Ranges: bytes</li>\n</ul>\n</li>\n<li>Access-Control-Allow-Origin\n<ul>\n<li>配置有权限访问资源的域</li>\n<li>Access-Control-Allow-Origin: &lt;origin&gt;|*</li>\n</ul>\n</li>\n<li>Age\n<ul>\n<li>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</li>\n<li>Age: 12</li>\n</ul>\n</li>\n<li>Allow\n<ul>\n<li>对某网络资源的有效的请求行为，不允许则返回 405</li>\n<li>Allow: GET, HEAD</li>\n</ul>\n</li>\n<li>Cache-Control\n<ul>\n<li>告诉所有的缓存机制是否可以缓存及哪种类型</li>\n<li>Cache-Control: no-cache</li>\n</ul>\n</li>\n<li>Content-Encoding\n<ul>\n<li>web 服务器支持的返回内容压缩编码类型</li>\n<li>Content-Encoding: gzip</li>\n</ul>\n</li>\n<li>Content-Language\n<ul>\n<li>响应体的语言</li>\n<li>Content-Language: en,zh</li>\n</ul>\n</li>\n<li>Content-Length\n<ul>\n<li>响应体的长度</li>\n<li>Content-Length: 348</li>\n</ul>\n</li>\n<li>Content-Location\n<ul>\n<li>请求资源可替代的备用的另一地址</li>\n<li>Content-Location: /index.htm</li>\n</ul>\n</li>\n<li>Content-MD5\n<ul>\n<li>返回资源的 MD5 校验值</li>\n<li>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</li>\n</ul>\n</li>\n<li>Content-Range\n<ul>\n<li>在整个返回体中本部分的字节位置</li>\n<li>Content-Range: bytes 21010-47021/47022</li>\n</ul>\n</li>\n<li>Content-Type\n<ul>\n<li>返回内容的 MIME 类型</li>\n<li>Content-Type: text/html; charset=utf-8</li>\n</ul>\n</li>\n<li>Date\n<ul>\n<li>原始服务器消息发出的时间</li>\n<li>Date: Tue, 15 Nov 2010 08:12:31 GMT</li>\n</ul>\n</li>\n<li>ETag\n<ul>\n<li>请求变量的实体标签的当前值</li>\n<li>ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</li>\n</ul>\n</li>\n<li>Expires\n<ul>\n<li>响应过期的日期和时间</li>\n<li>Expires: Thu, 01 Dec 2010 16:00:00 GMT</li>\n</ul>\n</li>\n<li>Last-Modified\n<ul>\n<li>请求资源的最后修改时间</li>\n<li>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</li>\n</ul>\n</li>\n<li>Location\n<ul>\n<li>用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源</li>\n<li>Location: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvOTQuaHRtbA==\">http://www.zcmhi.com/archives/94.html</span></li>\n</ul>\n</li>\n<li>Pragma\n<ul>\n<li>包括实现特定的指令，它可应用到响应链上的任何接收方</li>\n<li>Pragma: no-cache</li>\n</ul>\n</li>\n<li>Proxy-Authenticate\n<ul>\n<li>它指出认证方案和可应用到代理的该 URL 上的参数</li>\n<li>Proxy-Authenticate: Basic</li>\n</ul>\n</li>\n<li>Refresh\n<ul>\n<li>应用于重定向或一个新的资源被创造，在 5 秒之后重定向（由网景提出，被大部分浏览器支持）</li>\n<li>Refresh: 5; url=http://www.zcmhi.com/archives/94.html</li>\n</ul>\n</li>\n<li>Retry-After\n<ul>\n<li>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</li>\n<li>Retry-After: 120</li>\n</ul>\n</li>\n<li>Server\n<ul>\n<li>web 服务器软件名称</li>\n<li>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</li>\n</ul>\n</li>\n<li>Set-Cookie\n<ul>\n<li>设置 Http Cookie</li>\n<li>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</li>\n</ul>\n</li>\n<li>Strict-Transport-Security\n<ul>\n<li>设置浏览器强制使用 HTTPS 访问</li>\n<li>max-age: x 秒的时间内 访问对应域名都使用 HTTPS 请求</li>\n<li>includeSubDomains: 网站的子域名也启用规则</li>\n<li>Strict-Transport-Security: max-age=1000; includeSubDomains</li>\n</ul>\n</li>\n<li>Trailer\n<ul>\n<li>指出头域在分块传输编码的尾部存在</li>\n<li>Trailer: Max-Forwards</li>\n</ul>\n</li>\n<li>Transfer-Encoding\n<ul>\n<li>文件传输编码</li>\n<li>Transfer-Encoding:chunked</li>\n</ul>\n</li>\n<li>Vary\n<ul>\n<li>告诉下游代理是使用缓存响应还是从原始服务器请求</li>\n<li>Vary: *</li>\n</ul>\n</li>\n<li>Via\n<ul>\n<li>告知代理客户端响应是通过哪里发送的</li>\n<li>Via: 1.0 fred, 1.1 <span class=\"exturl\" data-url=\"aHR0cDovL25vd2hlcmUuY29t\">nowhere.com</span> (Apache/1.1)</li>\n</ul>\n</li>\n<li>Warning\n<ul>\n<li>警告实体可能存在的问题</li>\n<li>Warning: 199 Miscellaneous warning</li>\n</ul>\n</li>\n<li>WWW-Authenticate\n<ul>\n<li>表明客户端请求实体应该使用的授权方案</li>\n<li>WWW-Authenticate: Basic</li>\n</ul>\n</li>\n<li>X-Content-Type-Options\n<ul>\n<li>配置禁止 MIME 类型嗅探</li>\n<li>X-Content-Type-Options: nosniff</li>\n</ul>\n</li>\n<li>X-Frame-Options\n<ul>\n<li>配置页面是否能出现在 &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt; 等标签中，防止点击劫持</li>\n<li>X-Frame-Options: deny</li>\n</ul>\n</li>\n<li>X-XSS-Protection\n<ul>\n<li>配置 XSS 防护机制</li>\n<li>X-XSS-Protection: 1; mode=block</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"http状态返回代码-1xx临时响应\"><a class=\"anchor\" href=\"#http状态返回代码-1xx临时响应\">#</a> HTTP 状态返回代码 1xx（临时响应）</h2>\n<p>表示临时响应并需要请求者继续执行操作的状态代码。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>继续</td>\n<td>服务器返回此代码表示已收到请求的第一部分，正在等待其余部分</td>\n</tr>\n<tr>\n<td>101</td>\n<td>切换协议</td>\n<td>请求者已要求服务器切换协议，服务器已确认并准备切换</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http状态返回代码-2xx-成功\"><a class=\"anchor\" href=\"#http状态返回代码-2xx-成功\">#</a> HTTP 状态返回代码 2xx （成功）</h2>\n<p>表示成功处理了请求的状态代码。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>成功</td>\n<td>服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页</td>\n</tr>\n<tr>\n<td>201</td>\n<td>已创建</td>\n<td>请求成功并且服务器创建了新的资源</td>\n</tr>\n<tr>\n<td>202</td>\n<td>已接受</td>\n<td>服务器已接受请求，但尚未处理</td>\n</tr>\n<tr>\n<td>203</td>\n<td>非授权信息</td>\n<td>服务器已成功处理了请求，但返回的信息可能来自另一来源</td>\n</tr>\n<tr>\n<td>204</td>\n<td>无内容</td>\n<td>服务器成功处理了请求，但没有返回任何内容</td>\n</tr>\n<tr>\n<td>205</td>\n<td>重置内容</td>\n<td>m 服务器成功处理了请求，但没有返回任何内容</td>\n</tr>\n<tr>\n<td>206</td>\n<td>部分内容</td>\n<td>服务器成功处理了部分 GET 请求</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http状态返回代码-3xx-重定向\"><a class=\"anchor\" href=\"#http状态返回代码-3xx-重定向\">#</a> HTTP 状态返回代码 3xx （重定向）</h2>\n<p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>300</td>\n<td>多种选择</td>\n<td>针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>永久移动</td>\n<td>请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td>\n</tr>\n<tr>\n<td>302</td>\n<td>临时移动</td>\n<td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>查看其他位置</td>\n<td>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td>\n</tr>\n<tr>\n<td>304</td>\n<td>未修改</td>\n<td>自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>使用代理</td>\n<td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>临时重定向</td>\n<td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http状态返回代码-4xx请求错误\"><a class=\"anchor\" href=\"#http状态返回代码-4xx请求错误\">#</a> HTTP 状态返回代码 4xx（请求错误）</h2>\n<p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>错误请求</td>\n<td>服务器不理解请求的语法。</td>\n</tr>\n<tr>\n<td>401</td>\n<td>未授权</td>\n<td>请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>禁止</td>\n<td>服务器拒绝请求。</td>\n</tr>\n<tr>\n<td>404</td>\n<td>未找到</td>\n<td>服务器找不到请求的网页。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>方法禁用</td>\n<td>禁用请求中指定的方法。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>不接受</td>\n<td>无法使用请求的内容特性响应请求的网页。</td>\n</tr>\n<tr>\n<td>407</td>\n<td>需要代理授权</td>\n<td>此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>请求超时</td>\n<td>服务器等候请求时发生超时。</td>\n</tr>\n<tr>\n<td>409</td>\n<td>冲突</td>\n<td>服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</td>\n</tr>\n<tr>\n<td>410</td>\n<td>已删除</td>\n<td>如果请求的资源已永久删除，服务器就会返回此响应。</td>\n</tr>\n<tr>\n<td>411</td>\n<td>需要有效长度</td>\n<td>服务器不接受不含有效内容长度标头字段的请求。</td>\n</tr>\n<tr>\n<td>412</td>\n<td>未满足前提条件</td>\n<td>服务器未满足请求者在请求中设置的其中一个前提条件。</td>\n</tr>\n<tr>\n<td>413</td>\n<td>请求实体过大</td>\n<td>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td>\n</tr>\n<tr>\n<td>414</td>\n<td>请求的 URI 过长</td>\n<td>请求的 URI（通常为网址）过长，服务器无法处理。</td>\n</tr>\n<tr>\n<td>415</td>\n<td>不支持的媒体类型</td>\n<td>请求的格式不受请求页面的支持。</td>\n</tr>\n<tr>\n<td>416</td>\n<td>请求范围不符合要求</td>\n<td>如果页面无法提供请求的范围，则服务器会返回此状态代码。</td>\n</tr>\n<tr>\n<td>417</td>\n<td>未满足期望值</td>\n<td>服务器未满足 &quot;期望&quot; 请求标头字段的要求。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http状态返回代码-5xx服务器错误\"><a class=\"anchor\" href=\"#http状态返回代码-5xx服务器错误\">#</a> HTTP 状态返回代码 5xx（服务器错误）</h2>\n<p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>服务器内部错误</td>\n<td>服务器遇到错误，无法完成请求。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>尚未实施</td>\n<td>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td>\n</tr>\n<tr>\n<td>502</td>\n<td>错误网关</td>\n<td>服务器作为网关或代理，从上游服务器收到无效响应。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>服务不可用</td>\n<td>服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</td>\n</tr>\n<tr>\n<td>504</td>\n<td>网关超时</td>\n<td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP 版本不受支持</td>\n<td>服务器不支持请求中所用的 HTTP 协议版本。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"http-版本\"><a class=\"anchor\" href=\"#http-版本\">#</a> HTTP 版本</h1>\n<h2 id=\"http\"><a class=\"anchor\" href=\"#http\">#</a> HTTP</h2>\n<p>HTTP 是基于 TCP/IP 协议的应用层协议，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。</p>\n<h2 id=\"http-09\"><a class=\"anchor\" href=\"#http-09\">#</a> HTTP 0.9</h2>\n<p>HTTP 0.9 最早在 1991 年发布，仅支持 GET 命令，请求格式只有简单的  <code>GET /url</code>  ，服务端仅响应 HTML，响应完毕后关闭 TCP 连接。</p>\n<h2 id=\"http-10\"><a class=\"anchor\" href=\"#http-10\">#</a> HTTP 1.0</h2>\n<p>1996 年 5 月，HTTP/1.0 版本发布，丰富了传输的格式和内容，还引入了 POST、HEAD 两个动词。从 1.0 开始，必须在尾部添加协议版本。在 1.0 中，也引入了状态码 (status code)、多字符集支持、多部分发送 (multi-part type)、权限 (authorization)、缓存 (cache)、内容编码 (content encoding) 等内容。</p>\n<p>HTTP 1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>\n<p>TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢 (slow start)，所以，HTTP 1.0 版本的性能比较差。</p>\n<h2 id=\"http-11\"><a class=\"anchor\" href=\"#http-11\">#</a> HTTP 1.1</h2>\n<p>1997 年 1 月，HTTP/1.1 版本发布，进一步完善了 HTTP 协议。1.1 版本主要是引入了持久连接、管道机制、Content-Length、分块传输编码等内容。管道机制即在同一个 TCP 连接里面，客户端可以同时发送多个请求，这样就改进了 HTTP 协议的效率。PUT、PATCH、HEAD、 OPTIONS、DELETE 等动词方法也是在 HTTP 1.1 版本引入的。另外 1.1 版本新增了 Host 字段，用于指定服务器的域名，这也是后来虚拟主机得以发展的基础。</p>\n<p>虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。如果有一个请求很慢，就会阻塞后面的请求。</p>\n<h2 id=\"spdy\"><a class=\"anchor\" href=\"#spdy\">#</a> SPDY</h2>\n<p>2009 年，谷歌公开了自行研发的 SPDY 协议，用于解决 HTTP/1.1 效率不高的问题，而后被当做 HTTP/2 的基础。</p>\n<h2 id=\"http2\"><a class=\"anchor\" href=\"#http2\">#</a> HTTP/2</h2>\n<p>2015 年，HTTP/2 发布，HTTP/2 是一个二进制协议，头信息和数据体都是二进制，统称为帧 (frame)，帧分为头信息帧和数据帧。HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序回应。</p>\n<h1 id=\"https\"><a class=\"anchor\" href=\"#https\">#</a> HTTPS</h1>\n<h2 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h2>\n<p>HTTPS (HyperText Transfer Protocol over Secure Socket Layer) 可以理解为 HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。</p>\n<h2 id=\"交互\"><a class=\"anchor\" href=\"#交互\">#</a> 交互</h2>\n<h3 id=\"证书验证阶段\"><a class=\"anchor\" href=\"#证书验证阶段\">#</a> 证书验证阶段</h3>\n<ul>\n<li>浏览器发起 HTTPS 请求</li>\n<li>服务端返回 HTTPS 证书\n<ul>\n<li>其中证书包含：\n<ul>\n<li>颁发机构信息</li>\n<li>公钥</li>\n<li>公司信息</li>\n<li>域名</li>\n<li>有效期</li>\n<li>指纹</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>客户端验证证书是否合法，如果不合法则提示告警</li>\n</ul>\n<h3 id=\"数据传输阶段\"><a class=\"anchor\" href=\"#数据传输阶段\">#</a> 数据传输阶段</h3>\n<ul>\n<li>当证书验证合法后，在本地生成随机数</li>\n<li>通过公钥加密随机数，并把加密后的随机数传输到服务端</li>\n<li>服务端通过私钥对随机数进行解密</li>\n<li>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</li>\n</ul>\n<h2 id=\"ca\"><a class=\"anchor\" href=\"#ca\">#</a> CA</h2>\n<p>CA (Certificate Authority) 是颁发数字证书的机构。是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p>\n<h1 id=\"websocket\"><a class=\"anchor\" href=\"#websocket\">#</a> WebSocket</h1>\n<h2 id=\"简介-2\"><a class=\"anchor\" href=\"#简介-2\">#</a> 简介</h2>\n<p>WebSocket 是一种网络传输协议，可在单个 TCP 连接上进行全双工通信，位于 OSI 模型的应用层。WebSocket 协议在 2011 年由 IETF 标准化为 RFC 6455，后由 RFC 7936 补充规范。</p>\n<h2 id=\"交互-2\"><a class=\"anchor\" href=\"#交互-2\">#</a> 交互</h2>\n<h3 id=\"握手\"><a class=\"anchor\" href=\"#握手\">#</a> 握手</h3>\n<p>握手阶段和 HTTP 协议较为类似，RFC 文档中给出的握手示例如下：</p>\n<pre><code>GET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nOrigin: http://example.com\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n</code></pre>\n<p>其中 Upgrade 的值必须为 websocket ，Connection 的值必须为 Upgrade ，合起来表示客户端喜欢连接升级到 Websocket 协议。</p>\n<p>Sec-WebSocket-Key 是一个随机值，Sec-WebSocket-Accept 是 Sec-WebSocket-Key 拼接特定字符串  <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>  计算 SHA1 摘要后的 Base64 编码的值。例子中  <code>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</code>  就是  <code>dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>  对应的 SHA1 摘要。</p>\n<h1 id=\"cookie\"><a class=\"anchor\" href=\"#cookie\">#</a> Cookie</h1>\n<h2 id=\"2751-简介\"><a class=\"anchor\" href=\"#2751-简介\">#</a> 2.7.5.1. 简介</h2>\n<p>Cookie（复数形态 Cookies），类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。</p>\n<h2 id=\"2752-属性\"><a class=\"anchor\" href=\"#2752-属性\">#</a> 2.7.5.2. 属性</h2>\n<h3 id=\"name\"><a class=\"anchor\" href=\"#name\">#</a> name</h3>\n<p>cookie 的名称。</p>\n<h3 id=\"value\"><a class=\"anchor\" href=\"#value\">#</a> value</h3>\n<p>cookie 的值。</p>\n<h3 id=\"expires\"><a class=\"anchor\" href=\"#expires\">#</a> expires</h3>\n<p>当 Expires 属性缺省时，表示是会话性 Cookie，在用户关闭浏览器时失效。</p>\n<h3 id=\"max-age\"><a class=\"anchor\" href=\"#max-age\">#</a> max-age</h3>\n<p>max-age 可以为正数、负数、0。如果 max-age 属性为正数时，浏览器会将其持久化，当 max-age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。当 max-age 为 0 时，则会立即删除这个 Cookie。Expires 和 max-age 都存在的条件下，max-age 优先级更高。</p>\n<h3 id=\"domain\"><a class=\"anchor\" href=\"#domain\">#</a> domain</h3>\n<p>指定 Cookie 的域名，默认是当前域名。domain 设置时可以设置为自身及其父域，子域可以访问父域的 Cookie，反之不能。</p>\n<h3 id=\"path\"><a class=\"anchor\" href=\"#path\">#</a> path</h3>\n<p>指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送对应的 Cookie。</p>\n<h3 id=\"secure\"><a class=\"anchor\" href=\"#secure\">#</a> secure</h3>\n<p>只能通过 HTTPS 传输。</p>\n<h3 id=\"httponly\"><a class=\"anchor\" href=\"#httponly\">#</a> httponly</h3>\n<p>限制 Cookie 仅在 HTTP 传输过程中被读取，一定程度上防御 XSS 攻击。</p>\n<h3 id=\"samesite\"><a class=\"anchor\" href=\"#samesite\">#</a> SameSite</h3>\n<p>SameSite 支持 Strict / Lax / None 三种值。Strict 最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。Lax 允许部分第三方请求携带 Cookie，主要是链接、预加载、GET 表单三种情况。Cookie 的 SameSite 属性为 None ，且设置了 Secure 时，无论是否跨站都会发送 Cookie。</p>\n<h1 id=\"webdav\"><a class=\"anchor\" href=\"#webdav\">#</a> WebDAV</h1>\n<h2 id=\"简介-3\"><a class=\"anchor\" href=\"#简介-3\">#</a> 简介</h2>\n<p>WebDAV （Web-based Distributed Authoring and Versioning） 一种基于 HTTP 1.1 协议的通信协议。它扩展了 HTTP 1.1，在 GET、POST、HEAD 等几个 HTTP 标准方法以外添加了一些新的方法，使应用程序可对 Web Server 直接读写，并支持写文件锁定、解锁，以及版本控制等功能。</p>\n<p>支持的方法具体为：</p>\n<ul>\n<li>OPTIONS\n<ul>\n<li>获取服务器的支持</li>\n</ul>\n</li>\n<li>GET / PUT / POST / DELETE\n<ul>\n<li>资源操作</li>\n</ul>\n</li>\n<li>TRACE\n<ul>\n<li>跟踪服务器</li>\n</ul>\n</li>\n<li>HEAD</li>\n<li>MKCOL\n<ul>\n<li>创建集合</li>\n</ul>\n</li>\n<li>PROPFIND / PROPPATCH</li>\n<li>COPY / MOVE</li>\n<li>LOCK / UNLOCK</li>\n</ul>\n<h2 id=\"相关cve\"><a class=\"anchor\" href=\"#相关cve\">#</a> 相关 CVE</h2>\n<ul>\n<li>CVE-2015-1833\n<ul>\n<li>Apache Jacrabbit WebDav XXE</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zZWN1cml0eWZvY3VzLmNvbS9hcmNoaXZlLzEvNTM1NTgy\">http://www.securityfocus.com/archive/1/535582</span></li>\n</ul>\n</li>\n<li>CVE-2015-7326\n<ul>\n<li>Milton WebDav XXE</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zZWN1cml0eWZvY3VzLmNvbS9hcmNoaXZlLzEvNTM2ODEz\">http://www.securityfocus.com/archive/1/536813</span></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<h2 id=\"rfc\"><a class=\"anchor\" href=\"#rfc\">#</a> RFC</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNTM=\">RFC 3253</span> Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2NDg=\">RFC 3648</span> Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM3NDQ=\">RFC 3744</span> Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ0Mzc=\">RFC 4437</span> Web Distributed Authoring and Versioning (WebDAV) Redirect Reference Resources</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ5MTg=\">RFC 4918</span> HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjM=\">RFC 5323</span> Web Distributed Authoring and Versioning (WebDAV) SEARCH</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU4NDI=\">RFC 5842</span> Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1\">The WebSocket Protocol</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3OTM2\">Clarifying Registry Procedures for the WebSocket Subprotocol Name Registry</span></li>\n</ul>\n<h2 id=\"blog\"><a class=\"anchor\" href=\"#blog\">#</a> Blog</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovLzIwMTUuemVyb25pZ2h0cy5vcmcvYXNzZXRzL2ZpbGVzLzM1LUVnb3Jvdi5wZGY=\">What should a hacker know about WebDav</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTkvMDkvY29va2llLXNhbWVzaXRlLmh0bWw=\">Cookie 的 SameSite 属性</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDgvaHR0cC5odG1s\">HTTP 协议入门</span></li>\n</ul>\n",
            "tags": [
                "HTTP"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/DNS/",
            "url": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/DNS/",
            "title": "域名系统",
            "date_published": "2022-11-25T02:06:09.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>DNS 是一个简单的请求 - 响应协议，是将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 协议的 53 端口。</p>\n<h1 id=\"请求响应\"><a class=\"anchor\" href=\"#请求响应\">#</a> 请求响应</h1>\n<h2 id=\"dns记录\"><a class=\"anchor\" href=\"#dns记录\">#</a> DNS 记录</h2>\n<ul>\n<li>\n<p>A</p>\n<ul>\n<li>返回域名对应的 IPv4 地址</li>\n</ul>\n</li>\n<li>\n<p>AAAA</p>\n</li>\n<li>\n<p>NS</p>\n<ul>\n<li>\n<p>域名服务器</p>\n</li>\n<li>\n<p>返回该域名由哪台域名服务器解析</p>\n</li>\n</ul>\n</li>\n<li>\n<p>PTR</p>\n<ul>\n<li>反向记录</li>\n<li>从 IP 地址到域名的记录</li>\n</ul>\n</li>\n<li>\n<p>MX</p>\n<ul>\n<li>电子邮件交换记录</li>\n<li>记录邮件域名对应的 IP 地址</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"响应码\"><a class=\"anchor\" href=\"#响应码\">#</a> 响应码</h2>\n<ul>\n<li>NOERROR</li>\n</ul>\n<pre><code>No error condition\n</code></pre>\n<ul>\n<li>FORMERR</li>\n</ul>\n<pre><code>Format error - The name server was unable to interpret the query\n</code></pre>\n<ul>\n<li>SERVFAIL</li>\n</ul>\n<pre><code>Server failure - The name server was unable to process this query due to a problem with the name server\n</code></pre>\n<ul>\n<li>NXDOMAIN</li>\n</ul>\n<pre><code>this code signifies that the domain name referenced in the query does not exist\n</code></pre>\n<ul>\n<li>NOTIMP</li>\n</ul>\n<pre><code>Not Implemented - The name server does not support the requested kind of query\n</code></pre>\n<ul>\n<li>REFUSED</li>\n</ul>\n<pre><code>Refused - The name server refuses to perform the specified operation for policy reasons\n</code></pre>\n<ul>\n<li>NODATA</li>\n</ul>\n<pre><code>A pseudo RCODE which indicates that the name is valid, for the given class, but [there] are no records of the given type A NODATA response has to be inferred from the answer.\n</code></pre>\n<h1 id=\"域名系统工作原理\"><a class=\"anchor\" href=\"#域名系统工作原理\">#</a> 域名系统工作原理</h1>\n<h2 id=\"解析过程\"><a class=\"anchor\" href=\"#解析过程\">#</a> 解析过程</h2>\n<p>DNS 解析过程是递归查询的，具体过程如下：</p>\n<ul>\n<li>用户要访问域名 www.example.com 时，先查看本机 hosts 是否有记录或者本机是否有 DNS 缓存，如果有，直接返回结果，否则向递归服务器查询该域名的 IP 地址</li>\n<li>递归缓存为空时，首先向根服务器查询 com 顶级域的 IP 地址</li>\n<li>根服务器告知递归服务器 com 顶级域名服务器的 IP 地址</li>\n<li>递归向 com 顶级域名服务器查询负责 example.com 的权威服务器的 IP</li>\n<li>com 顶级域名服务器返回相应的 IP 地址</li>\n<li>递归向 example.com 的权威服务器查询 www.example.com 的地址记录</li>\n<li>权威服务器告知 www.example.com 的地址记录</li>\n<li>递归服务器将查询结果返回客户端</li>\n</ul>\n<h2 id=\"域传送\"><a class=\"anchor\" href=\"#域传送\">#</a> 域传送</h2>\n<p>DNS 服务器可以分为主服务器、备份服务器和缓存服务器。域传送是指备份服务器从主服务器拷贝数据，并使用得到的数据更新自身数据库。域传送是在主备服务器之间同步数据库的机制。</p>\n<h1 id=\"服务器类型\"><a class=\"anchor\" href=\"#服务器类型\">#</a> 服务器类型</h1>\n<h2 id=\"根服务器\"><a class=\"anchor\" href=\"#根服务器\">#</a> 根服务器</h2>\n<p>根服务器是 DNS 的核心，负责互联网顶级域名的解析，用于维护域的权威信息，并将 DNS 查询引导到相应的域名服务器。</p>\n<p>根服务器在域名树中代表最顶级的  <code>.</code>  域， 一般省略。</p>\n<p>13 台 IPv4 根服务器的域名标号为 a 到 m，即 <span class=\"exturl\" data-url=\"aHR0cDovL2Eucm9vdC1zZXJ2ZXJzLm9yZw==\">a.root-servers.org</span> 到 <span class=\"exturl\" data-url=\"aHR0cDovL20ucm9vdC1zZXJ2ZXJzLm9yZw==\">m.root-servers.org</span>，所有服务器存储的数据相同，仅包含 ICANN 批准的 TLD 域名权威信息。</p>\n<h2 id=\"权威服务器\"><a class=\"anchor\" href=\"#权威服务器\">#</a> 权威服务器</h2>\n<p>权威服务器上存储域名 Zone 文件，维护域内域名的权威信息，递归服务器可以从权威服务器获得 DNS 查询的资源记录。</p>\n<p>权威服务器需要在所承载的域名所属的 TLD 管理局注册，同一个权威服务器可以承载不同 TLD 域名，同一个域也可以有多个权威服务器。</p>\n<h2 id=\"递归服务器\"><a class=\"anchor\" href=\"#递归服务器\">#</a> 递归服务器</h2>\n<p>递归服务器负责接收用户的查询请求，进行递归查询并响应用户查询请求。在初始时递归服务器仅有记录了根域名的 Hint 文件。</p>\n<h1 id=\"加密方案\"><a class=\"anchor\" href=\"#加密方案\">#</a> 加密方案</h1>\n<p>作为主流的防御方案，DNS 加密有五种方案，分别是 DNS-over-TLS (DoT)、DNS-over-DTLS、DNS-over-HTTPS (DoH)、DNS-over-QUIC 以及 DNSCrypt。</p>\n<h2 id=\"dot\"><a class=\"anchor\" href=\"#dot\">#</a> DoT</h2>\n<p>DoT 方案在 2016 年发表于 RFC7858，使用 853 端口。主要思想是 Client 和 Server 通过 TCP 协议建立 TLS 会话后再进行 DNS 传输，Client 通过 SSL 证书验证服务器身份。</p>\n<h2 id=\"dns-over-dtls\"><a class=\"anchor\" href=\"#dns-over-dtls\">#</a> DNS-over-DTLS</h2>\n<p>DNS-over-DTLS 和 DoT 类似，区别在于使用 UDP 协议而不是 TCP 协议。</p>\n<h2 id=\"doh\"><a class=\"anchor\" href=\"#doh\">#</a> DoH</h2>\n<p>DoH 方案在发表 RFC8484，使用  <code>https://dns.example.com/dns-query&#123;?dns&#125;</code>  来查询服务器的 IP，复用 https 的 443 端口，流量特征比较小。DoH 会对 DNS 服务器进行加密认证，不提供 fallback 选项。目前 Cloudflare、Google 等服务商对 DoH 提供了支持。</p>\n<h2 id=\"dns-over-quic\"><a class=\"anchor\" href=\"#dns-over-quic\">#</a> DNS-over-QUIC</h2>\n<p>DNS-over-QUIC 安全特性和 DoT 类似，但是性能更高，目前没有合适的软件实现。</p>\n<h2 id=\"dnscrypt\"><a class=\"anchor\" href=\"#dnscrypt\">#</a> DNSCrypt</h2>\n<p>DNSCrypt 使用 X25519-XSalsa20Poly1305 而非标准的 TLS，且 DNSCrypt 的 Client 需要额外的软件，Server 需要的专门的证书。</p>\n<h1 id=\"dns利用\"><a class=\"anchor\" href=\"#dns利用\">#</a> DNS 利用</h1>\n<h2 id=\"dga\"><a class=\"anchor\" href=\"#dga\">#</a> DGA</h2>\n<p>DGA（Domain Generate Algorithm，域名生成算法）是一种利用随机字符来生成 C&amp;C 域名，从而逃避域名黑名单检测的技术手段，常见于 botnet 中。一般来说，一个 DGA 域名的存活时间约在 1-7 天左右。</p>\n<p>通信时，客户端和服务端都运行同一套 DGA 算法，生成相同的备选域名列表，当需要发动攻击的时候，选择其中少量进行注册，便可以建立通信，并且可以对注册的域名应用速变 IP 技术，快速变换 IP，从而域名和 IP 都可以进行快速变化。</p>\n<p>DGA 域名有多种生成方式，根据种子类型可以分为确定性和不确定性的生成。不确定性的种子可能会选用当天的一些即时数据，如汇率信息等。</p>\n<h2 id=\"dns隧道\"><a class=\"anchor\" href=\"#dns隧道\">#</a> DNS 隧道</h2>\n<p>DNS 隧道工具将进入隧道的其他协议流量封装到 DNS 协议内，在隧道上传输。这些数据包出隧道时进行解封装，还原数据。</p>\n<h1 id=\"rdap\"><a class=\"anchor\" href=\"#rdap\">#</a> RDAP</h1>\n<p>RDAP (Registration Data Access Protocol) 协议是 Whois 协议的后继，和 Whois 协议类似，RDAP 协议提供了域名、自治系统、IP 地址的信息查询。</p>\n<h1 id=\"相关漏洞\"><a class=\"anchor\" href=\"#相关漏洞\">#</a> 相关漏洞</h1>\n<h2 id=\"dns劫持\"><a class=\"anchor\" href=\"#dns劫持\">#</a> DNS 劫持</h2>\n<p>DNS 劫持有多种方式，比较早期的攻击方式是通过攻击域名解析服务器，或是伪造 DNS 响应的方法，来将域名解析到恶意的 IP 地址。</p>\n<p>随着互联网应用的不断发展，出现了基于废弃记录的劫持方式。这种方式发生的场景是次级域名的解析记录指向第三方资源，而第三方资源被释放后，解析记录并没有取消，在这种场景下，可以对应申请第三方资源，以获取控制解析记录的能力。</p>\n<h2 id=\"拒绝服务\"><a class=\"anchor\" href=\"#拒绝服务\">#</a> 拒绝服务</h2>\n<p>DNS 服务通常会开启 UDP 端口，当 DNS 服务器拥有大量二级域 NS 记录时，通过 DNS 的 UDP 反射攻击可以实现高倍的拒绝服务。</p>\n<h1 id=\"相关机构\"><a class=\"anchor\" href=\"#相关机构\">#</a> 相关机构</h1>\n<h2 id=\"icann\"><a class=\"anchor\" href=\"#icann\">#</a> ICANN</h2>\n<p>互联网名称与数字地址分配机构 (Internet Corporation for Assigned Names and Numbers, ICANN) 创建于 1998 年 9 月 18 日，职能包括管理域名和 IP 地址的分配等与互联网相关的任务。</p>\n<h2 id=\"iana\"><a class=\"anchor\" href=\"#iana\">#</a> IANA</h2>\n<p>互联网号码分配局 (Internet Assigned Numbers Authority, IANA) ，是一家互联网地址指派机构，管理国际互联网中使用的 IP 地址、域名和许多其它参数的机构。</p>\n<h1 id=\"术语\"><a class=\"anchor\" href=\"#术语\">#</a> 术语</h1>\n<h2 id=\"mdns\"><a class=\"anchor\" href=\"#mdns\">#</a> mDNS</h2>\n<p>Multicast DNS (mDNS)，多播 DNS，使用 5353 端口，组播地址为  <code>224.0.0.251</code>  或  <code>[FF02::FB]</code>  。在一个没有常规 DNS 服务器的小型网络内可以使用 mDNS 来实现类似 DNS 的编程接口、包格式和操作语义。mDNS 协议的报文与 DNS 的报文结构相同，但有些字段对于 mDNS 来说有新的含义。</p>\n<p>启动 mDNS 的主机会在进入局域网后向所有主机组播消息，包含主机名、IP 等信息，其他拥有相应服务的主机也会响应含有主机名和 IP 的信息。</p>\n<p>mDNS 的域名是用  <code>.local</code>  和普通域名区分开的。</p>\n<h2 id=\"fqdn\"><a class=\"anchor\" href=\"#fqdn\">#</a> FQDN</h2>\n<p>FQDN (Fully-Qualified Domain Name) 是域名的完全形态，主要是包含零长度的根标签，例如  <code>www.example.com.</code>  。</p>\n<h2 id=\"tld\"><a class=\"anchor\" href=\"#tld\">#</a> TLD</h2>\n<p>Top-Level Domain (TLD) 是属于根域的一个域，例如  <code>com</code>  或  <code>jp</code>  。</p>\n<p>TLD 一般可以分为 Country Code Top-Level Domains (ccTLDs) 、Generic Top-Level Domains (gTLDs) 以及其它。</p>\n<h2 id=\"idn\"><a class=\"anchor\" href=\"#idn\">#</a> IDN</h2>\n<p>Internationalized Domain Names for Applications (IDNA) 是为了处理非 ASCII 字符的情况。</p>\n<h2 id=\"cname\"><a class=\"anchor\" href=\"#cname\">#</a> CNAME</h2>\n<p>CNAME 即 Canonical name，又称 alias，将域名指向另一个域名。</p>\n<h2 id=\"ttl\"><a class=\"anchor\" href=\"#ttl\">#</a> TTL</h2>\n<p>Time To Live，无符号整数，记录 DNS 记录过期的时间，最小是 0，最大是 2147483647 (2^31 - 1)。</p>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<h2 id=\"rfc\"><a class=\"anchor\" href=\"#rfc\">#</a> RFC</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkyMA==\">RFC 920 Domain Requirements</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzQ=\">RFC 1034 DOMAIN NAMES CONCEPTS AND FACILITIES</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzU=\">RFC 1035 DOMAIN NAMES IMPLEMENTATION AND SPECIFICATION</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExMjM=\">RFC 1123 Requirements for Internet Hosts -- Application and Support</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI1MzU=\">RFC 2535 Domain Name System Security Extensions</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI5MzA=\">RFC 2930 Secret Key Establishment for DNS (TKEY RR)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI5MzE=\">RFC 2931 DNS Request and Transaction Signatures ( SIG(0)s )</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1OTY=\">RFC 3596 Legacy Resolver Compatibility for Delegation Signer (DS)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM3NTU=\">RFC 3755 DNS Extensions to Support IP Version 6</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUwMDE=\">RFC 5001 Automated Updates of DNS Security (DNSSEC) Trust Anchors</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU5MzY=\">RFC 5936 DNS Zone Transfer Protocol</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU5NjY=\">RFC 5966 DNS Transport over TCP - Implementation Requirements</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYzNzY=\">RFC 6376 DomainKeys Identified Mail (DKIM) Signatures</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NjI=\">RFC 6762 Multicast DNS</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY4OTE=\">RFC 6891 Extension Mechanisms for DNS (EDNS(0))</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY4OTU=\">RFC 6895 DNS IANA Considerations</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc3NjY=\">RFC 7766 DNS Transport over TCP - Implementation Requirements</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc4NTg=\">RFC 7858 Specification for DNS over Transport Layer Security (TLS)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc4NzE=\">RFC 7871 Client Subnet in DNS Queries</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgwODI=\">RFC 8082 NXDOMAIN</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzg0ODI=\">RFC 8482 Providing Minimal-Sized Responses to DNS Queries That Have QTYPE=ANY</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzg0ODQ=\">RFC 8484 DNS Queries over HTTPS (DoH)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzg0OTA=\">RFC 8490 DNS Stateful Operations</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzg0OTk=\">RFC 8499 DNS Terminology</span></li>\n</ul>\n<h3 id=\"whois-相关\"><a class=\"anchor\" href=\"#whois-相关\">#</a> Whois 相关</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgxMg==\">RFC 812 NICNAME/WHOIS</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzk1NA==\">RFC 954 NICNAME/WHOIS</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIxNjc=\">RFC 2167 Referral Whois (RWhois) Protocol V1.5</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5MTI=\">RFC 3912 WHOIS Protocol Specification</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc0ODU=\">RFC 7485 Inventory and Analysis of WHOIS Registration Objects</span></li>\n</ul>\n<h3 id=\"rdap-相关\"><a class=\"anchor\" href=\"#rdap-相关\">#</a> RDAP 相关</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc0ODA=\">RFC7480 HTTP Usage in the Registration Data Access Protocol (RDAP)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc0ODE=\">RFC7481 Security Services for the Registration Data Access Protocol (RDAP)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc0ODQ=\">RFC7484 Finding the Authoritative Registration Data (RDAP) Service</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgwNTY=\">RFC8056 Registration Data Access Protocol (RDAP) Object Tagging</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzkwODI=\">RFC9082 Registration Data Access Protocol (RDAP) Query Format</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzkwODM=\">RFC9083 JSON Responses for the Registration Data Access Protocol (RDAP)</span></li>\n</ul>\n<h2 id=\"相关标准\"><a class=\"anchor\" href=\"#相关标准\">#</a> 相关标准</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYm91dC5yZGFwLm9yZy8=\">Registration Data Access Protocol (RDAP)</span></li>\n</ul>\n<h2 id=\"工具\"><a class=\"anchor\" href=\"#工具\">#</a> 工具</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL05MbmV0TGFicy91bmJvdW5k\">Unbound</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzYy1wcm9qZWN0cy9iaW5kOQ==\">bind9</span></li>\n</ul>\n<h2 id=\"研究文章\"><a class=\"anchor\" href=\"#研究文章\">#</a> 研究文章</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveGJmMFFicHBrOFIwbng4OVBiNFlUZw==\">DGA 域名的今生前世：缘起、检测、与发展</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLnRoZWNqdy5tZS8/cD0xMjIx\">DNSSEC 原理和分析</span></li>\n<li>Plohmann D, Yakdan K, Klatt M, et al. A comprehensive measurement study of domain generating malware[C]//25th {USENIX} Security Symposium ({USENIX} Security 16). 2016: 263-278.</li>\n<li>An End-to-End Large-Scale Measurement of DNS-over-Encryption: How Far Have We Come?</li>\n</ul>\n<h2 id=\"相关cve\"><a class=\"anchor\" href=\"#相关cve\">#</a> 相关 CVE</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZXNlYXJjaC5jaGVja3BvaW50LmNvbS8yMDIwL3Jlc29sdmluZy15b3VyLXdheS1pbnRvLWRvbWFpbi1hZG1pbi1leHBsb2l0aW5nLWEtMTcteWVhci1vbGQtYnVnLWluLXdpbmRvd3MtZG5zLXNlcnZlcnMv\">SIGRed – Resolving Your Way into Domain Admin: Exploiting a 17 Year-old Bug in Windows DNS Servers</span></li>\n</ul>\n",
            "tags": [
                "域名",
                "DNS",
                "WEB"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/protocol/",
            "url": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/protocol/",
            "title": "网络协议",
            "date_published": "2022-11-24T03:16:26.000Z",
            "content_html": "<h1 id=\"udp协议\"><a class=\"anchor\" href=\"#udp协议\">#</a> UDP 协议</h1>\n<h2 id=\"主要特点\"><a class=\"anchor\" href=\"#主要特点\">#</a> 主要特点</h2>\n<ul>\n<li>协议开销小、效率高。</li>\n<li>UDP 是无连接的，即发送数据之前不需要建立连接。</li>\n<li>UDP 使用尽最大努力交付，即不保证可靠交付。</li>\n<li>UDP 没有拥塞控制。</li>\n<li>UDP 支持一对一、一对多、多对一和多对多交互通信。</li>\n<li>UDP 的首部开销小，只有 8 个字节。</li>\n</ul>\n<h1 id=\"tcp协议\"><a class=\"anchor\" href=\"#tcp协议\">#</a> TCP 协议</h1>\n<h2 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h2>\n<p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 RFC 793 定义。</p>\n<h2 id=\"三次握手\"><a class=\"anchor\" href=\"#三次握手\">#</a> 三次握手</h2>\n<p>三次握手（Three-Way Handshake）是指建立一个 TCP 连接时，需要客户端和服务端总共发送 3 个包以确认连接的建立。</p>\n<p>第一次握手客户端将标志位 SYN 置为 1，随机产生一个值 seq=s ，并将该数据包发送给服务端，客户端进入 SYN_SENT 状态，等待服务端确认。</p>\n<p>第二次握手服务端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务端将标志位 SYN 和 ACK 都置为 1，ack=s+1，随机产生一个值 seq=k ，并将该数据包发送给客户端以确认连接请求，服务端进入 SYN_RCVD 状态。</p>\n<p>第三次握手客户端收到确认后，检查 ack 值是否为 s+1，ACK 标志位是否为 1，如果正确则将标志位 ACK 置为 1，ack=k+1，并将该数据包发送给服务端，服务端检查 ack 值是否为 k+1，ACK 标志位是否为 1，如果正确则连接建立成功，客户端和服务端进入 ESTABLISHED 状态，完成三次握手。</p>\n<h2 id=\"四次挥手\"><a class=\"anchor\" href=\"#四次挥手\">#</a> 四次挥手</h2>\n<p>四次挥手（Four-Way Wavehand）指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。</p>\n<p>第一次挥手客户端发送一个 FIN ，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态。</p>\n<p>第二次挥手服务端收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到序号 + 1，服务端进入 CLOSE_WAIT 状态。</p>\n<p>第三次挥手服务端发送一个 FIN ，用来关闭服务端到客户端的数据传送，服务端进入 LAST_ACK 状态。</p>\n<p>第四次挥手客户端收到 FIN 后，客户端进入 TIME_WAIT 状态，接着发送一个 ACK 给服务端，确认序号为收到序号 + 1，服务端进入 CLOSED 状态，完成四次挥手。</p>\n<h2 id=\"拥塞控制\"><a class=\"anchor\" href=\"#拥塞控制\">#</a> 拥塞控制</h2>\n<p>拥塞是指网络中报文数量过多，使得服务端来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿即出现死锁现象。</p>\n<p>TCP 采用拥塞控制算法来减少或者避免拥塞现象的发生，TCP 的拥塞算法有过多种实现，包括 Tahoe、Reno、NewReno、Vegas、Hybla、BIC 、CUBIC、SACK、Westwood、PRR、BBR 等。</p>\n<h1 id=\"dhcp协议\"><a class=\"anchor\" href=\"#dhcp协议\">#</a> DHCP 协议</h1>\n<h2 id=\"简介-2\"><a class=\"anchor\" href=\"#简介-2\">#</a> 简介</h2>\n<p>动态主机配置协议 (Dynamic Host Configuration Protocol，DHCP) 是一个用于局域网的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要用于自动分配 IP 地址给用户，方便管理员进行统一管理。</p>\n<p>DHCP 服务器端使用 67/udp，客户端使用 68/udp。DHCP 运行分为四个基本过程，分别为请求 IP 租约、提供 IP 租约、选择 IP 租约和确认 IP 租约。客户端在获得了一个 IP 地址以后，就可以发送一个 ARP 请求来避免由于 DHCP 服务器地址池重叠而引发的 IP 冲突。</p>\n<h2 id=\"dhcp报文格式\"><a class=\"anchor\" href=\"#dhcp报文格式\">#</a> DHCP 报文格式</h2>\n<pre><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |\n+---------------+---------------+---------------+---------------+\n|                            xid (4)                            |\n+-------------------------------+-------------------------------+\n|           secs (2)            |           flags (2)           |\n+-------------------------------+-------------------------------+\n|                          ciaddr  (4)                          |\n+---------------------------------------------------------------+\n|                          yiaddr  (4)                          |\n+---------------------------------------------------------------+\n|                          siaddr  (4)                          |\n+---------------------------------------------------------------+\n|                          giaddr  (4)                          |\n+---------------------------------------------------------------+\n|                          chaddr  (16)                         |\n+---------------------------------------------------------------+\n|                          sname   (64)                         |\n+---------------------------------------------------------------+\n|                          file    (128)                        |\n+---------------------------------------------------------------+\n|                          options (variable)                   |\n+---------------------------------------------------------------+\n</code></pre>\n<h1 id=\"路由算法\"><a class=\"anchor\" href=\"#路由算法\">#</a> 路由算法</h1>\n<h2 id=\"简介-3\"><a class=\"anchor\" href=\"#简介-3\">#</a> 简介</h2>\n<p>路由算法是用于找到一条从源路由器到目的路由器的最佳路径的算法。存在着多种路由算法，每种算法对网络和路由器资源的影响都不同；由于路由算法使用多种度量标准 (metric)，所以不同路由算法的最佳路径选择也有所不同。</p>\n<h2 id=\"路由选择算法的功能\"><a class=\"anchor\" href=\"#路由选择算法的功能\">#</a> 路由选择算法的功能</h2>\n<p>源 / 宿对之间的路径选择，以及选定路由之后将报文传送到它们的目的地。</p>\n<p>路由选择算法的要求：</p>\n<ul>\n<li>正确性：确保分组从源节点传送到目的节点</li>\n<li>简单性：实现方便，软硬件开销小</li>\n<li>自适应性：也称健壮性，算法能够适应业务量和网络拓扑的变化</li>\n<li>稳定性：能长时间无故障运行</li>\n<li>公平性：每个节点都有机会传送信息</li>\n<li>最优性：尽量选取好的路由</li>\n</ul>\n<h2 id=\"自治系统autonomous-system\"><a class=\"anchor\" href=\"#自治系统autonomous-system\">#</a> 自治系统（Autonomous System）</h2>\n<p>经典定义：</p>\n<ul>\n<li>由一个组织管理的一整套路由器和网络。</li>\n<li>使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由。</li>\n<li>使用一种 AS 之间的路由选择协议用以确定分组在 AS 之间的路由。</li>\n</ul>\n<p>尽管一个 AS 使用了多种内部路由选择协议和度量，但对其他 AS 表现出的是一个单一的和一致的路由选择策略。</p>\n<h2 id=\"rip\"><a class=\"anchor\" href=\"#rip\">#</a> RIP</h2>\n<p>路由信息协议 (Routing Information Protocol, RIP) 是一种基于距离 向量的路由选择协议。RIP 协议要求网络中的每一个路由器都要维护从它自己到自治系统内其他每一个目的网络的距离和下一跳路由器地址。</p>\n<h2 id=\"ospf\"><a class=\"anchor\" href=\"#ospf\">#</a> OSPF</h2>\n<p>开放最短路径优先 (Open Shortest Path First，OSPF)，这个算法名为 “最短路径优先” 是因为使用了 Dijkstra 提出的最短路径算法 SPF，只是一个协议的名字，它并不表示其他的路由选择协议不是 “最短路径优先”。</p>\n",
            "tags": [
                "计算机网络",
                "网络协议"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/netw/",
            "url": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/netw/",
            "title": "计算机网络基础",
            "date_published": "2022-11-24T02:45:44.000Z",
            "content_html": "<h1 id=\"网络基础\"><a class=\"anchor\" href=\"#网络基础\">#</a> 网络基础</h1>\n<h2 id=\"计算机通信网的组成\"><a class=\"anchor\" href=\"#计算机通信网的组成\">#</a> 计算机通信网的组成</h2>\n<p>计算机网络由通信子网和资源子网组成。其中通信子网负责数据的无差错和有序传递，其处理功能包括差错控制、流量控制、路由选择、网络互连等。其中资源子网是计算机通信的本地系统环境，包括主机、终端和应用程序等，资源子网的主要功能是用户资源配置、数据的处理和管理、软件和硬件共享以及负载均衡等。总的来说，计算机通信网就是一个由通信子网承载的、传输和共享资源子网的各类信息的系统。</p>\n<h2 id=\"通信协议\"><a class=\"anchor\" href=\"#通信协议\">#</a> 通信协议</h2>\n<p>为了完成计算机之间有序的信息交换，提出了通信协议的概念，其定义是相互通信的双方（或多方）对如何进行信息交换所必须遵守的一整套规则。</p>\n<p>协议涉及到三个要素，分别为：</p>\n<ul>\n<li>语法：语法是用户数据与控制信息的结构与格式，以及数据出现顺序的意义</li>\n<li>语义：用于解释比特流的每一部分的意义</li>\n<li>时序：事件实现顺序的详细说明</li>\n</ul>\n<h2 id=\"osi七层模型\"><a class=\"anchor\" href=\"#osi七层模型\">#</a> OSI 七层模型</h2>\n<h3 id=\"物理层\"><a class=\"anchor\" href=\"#物理层\">#</a> 物理层</h3>\n<ul>\n<li>提供建立、维护和释放物理链路所需的机械、电气功能和规程等特性</li>\n<li>通过传输介质进行数据流 (比特流) 的物理传输、故障监测和物理层管理</li>\n<li>从数据链路层接收帧，将比特流转换成底层物理介质上的信号</li>\n</ul>\n<h3 id=\"网络层\"><a class=\"anchor\" href=\"#网络层\">#</a> 网络层</h3>\n<ul>\n<li>在物理链路的两端之间传输数据</li>\n<li>在网络层实体间提供数据传输功能和控制</li>\n<li>提供数据的流量控制</li>\n<li>检测和纠正物理链路产生的差错</li>\n<li>格式化的消息称为帧</li>\n</ul>\n<h3 id=\"传输层\"><a class=\"anchor\" href=\"#传输层\">#</a> 传输层</h3>\n<ul>\n<li>提供无差错的数据传输</li>\n<li>接收来自会话层的数据，如果需要，将数据分割成更小的分组，向网络层传送分组并确保分组完整和正确到达它们的目的地</li>\n<li>在系统之间提供可靠的透明的数据传输，提供端到端的错误恢复和流量控制</li>\n</ul>\n<h3 id=\"会话层\"><a class=\"anchor\" href=\"#会话层\">#</a> 会话层</h3>\n<ul>\n<li>提供节点之间通信过程的协调</li>\n<li>负责执行会话规则（如：连接是否允许半双工或全双工通信）、同步数据流以及当故障发生时重新建立连接</li>\n<li>使用上面的表示层和下面的传输层的功能</li>\n</ul>\n<h3 id=\"表示层\"><a class=\"anchor\" href=\"#表示层\">#</a> 表示层</h3>\n<ul>\n<li>提供数据格式、变换和编码转换</li>\n<li>涉及正在传输数据的语法和语义</li>\n<li>将消息以合适电子传输的格式编码</li>\n<li>执行该层的数据压缩和加密</li>\n<li>从应用层接收消息，转换格式，并传送到会话层，该层常合并在应用层中</li>\n</ul>\n<h3 id=\"应用层\"><a class=\"anchor\" href=\"#应用层\">#</a> 应用层</h3>\n<p>包括各种协议，它们定义了具体的面向用户的应用：如电子邮件、文件传输等</p>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>低三层模型属于通信子网，涉及为用户间提供透明连接，操作主要以每条链路（ hop-by-hop）为基础，在节点间的各条数据链路上进行通信。由网络层来控制各条链路上的通信，但要依赖于其他节点的协调操作。</p>\n<p>高三层属于资源子网，主要涉及保证信息以正确可理解形式传送。</p>\n<p>传输层是高三层和低三层之间的接口，它是第一个端到端的层次，保证透明的端到端连接，满足用户的服务质量（QoS）要求，并向高三层提供合适的信息形式。</p>\n<h2 id=\"tcpip四层模型\"><a class=\"anchor\" href=\"#tcpip四层模型\">#</a> TCP/IP 四层模型</h2>\n<h3 id=\"网络接口层\"><a class=\"anchor\" href=\"#网络接口层\">#</a> 网络接口层</h3>\n<p>网络接入层与 OSI 参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接。地址解析协议（ARP）工作在此层，即 OSI 参考模型的数据链路层。</p>\n<h3 id=\"网际层\"><a class=\"anchor\" href=\"#网际层\">#</a> 网际层</h3>\n<p>网际层对应于 OSI 参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个 IP 地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p>\n<h3 id=\"运输层\"><a class=\"anchor\" href=\"#运输层\">#</a> 运输层</h3>\n<p>运输层对应于 OSI 参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP)</p>\n<h3 id=\"应用层-2\"><a class=\"anchor\" href=\"#应用层-2\">#</a> 应用层</h3>\n<p>应用层对应于 OSI 参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP 等</p>\n<h2 id=\"osi模型与tcpip模型对比\"><a class=\"anchor\" href=\"#osi模型与tcpip模型对比\">#</a> OSI 模型与 TCP/IP 模型对比</h2>\n<p><img data-src=\"https://s2.loli.net/2022/11/24/7PVpnCLrqtSUDOM.jpg\" alt=\"\" /></p>\n<p>共同点<br />\n（1）OSI 参考模型和 TCP/IP 参考模型都采用了层次结构的概念。<br />\n（2）都能够提供面向连接和无连接两种通信服务机制。<br />\n不同点<br />\n（1）OSI 采用的七层模型，而 TCP/IP 是四层结构。<br />\n（2）TCP/IP 参考模型的网络接口层实际上并没有真正的定义，只是一些概念性的描述。而 OSI 参考模型不仅分了两层，而且每一层的功能都很详尽，甚至在数据链路层又分出一个介质访问子层，专门解决局域网的共享介质问题。<br />\n（3）OSI 模型是在协议开发前设计的，具有通用性。TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。<br />\n（4）OSI 参考模型与 TCP/IP 参考模型的传输层功能基本相似，都是负责为用户提供真正的端对端的通信服务，也对高层屏蔽了底层网络的实现细节。所不同的是 TCP/IP 参考模型的传输层是建立在网络互联层基础之上的，而网络互联层只提供无连接的网络服务，所以面向连接的功能完全在 TCP 协议中实现，当然 TCP/IP 的传输层还提供无连接的服务，如 UDP；相反 OSI 参考模型的传输层是建立在网络层基础之上的，网络层既提供面向连接的服务，又提供无连接的服务，但传输层只提供面向连接的服务。<br />\n（5）OSI 参考模型的抽象能力高，适合与描述各种网络；而 TCP/IP 是先有了协议，才制定 TCP/IP 模型的。<br />\n（6）OSI 参考模型的概念划分清晰，但过于复杂；而 TCP/IP 参考模型在服务、接口和协议的 区别上不清楚，功能描述和实现细节混在一起。<br />\n（7）TCP/IP 参考模型的网络接口层并不是真正的一层；OSI 参考模型的缺点是层次过多，划分意义不大但增加了复杂性。</p>\n",
            "tags": [
                "计算机网络",
                "网络协议"
            ]
        }
    ]
}