{
    "version": "https://jsonfeed.org/version/1",
    "title": "Khala • All posts by \"服务器\" tag",
    "description": "GLHF",
    "home_page_url": "https://mobius-0.github.io",
    "items": [
        {
            "id": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/HTTP%20request/",
            "url": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/HTTP%20request/",
            "title": "HTTP请求走私",
            "date_published": "2022-11-27T07:47:26.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>HTTP 请求走私是一种干扰网站处理 HTTP 请求序列方式的技术，最早在 2005 年的一篇 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2dpc2VjdXJpdHkuY29tL2xpYi9IVFRQLVJlcXVlc3QtU211Z2dsaW5nLnBkZg==\">文章</span> 中被提出。</p>\n<h1 id=\"成因\"><a class=\"anchor\" href=\"#成因\">#</a> 成因</h1>\n<p>请求走私大多发生于前端服务器和后端服务器对客户端传入的数据理解不一致的情况。这是因为 HTTP 规范提供了两种不同的方法来指定请求的结束位置，即  <code>Content-Length</code>  和  <code>Transfer-Encoding</code>  标头。</p>\n<h1 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类</h1>\n<ul>\n<li>CLTE：前端服务器使用  <code>Content-Length</code>  头，后端服务器使用  <code>Transfer-Encoding</code>  头</li>\n<li>TECL：前端服务器使用  <code>Transfer-Encoding</code>  标头，后端服务器使用  <code>Content-Length</code>  标头。</li>\n<li>TETE：前端和后端服务器都支持  <code>Transfer-Encoding</code>  标头，但是可以通过以某种方式来诱导其中一个服务器不处理它。</li>\n</ul>\n<h1 id=\"攻击\"><a class=\"anchor\" href=\"#攻击\">#</a> 攻击</h1>\n<h2 id=\"cl不为0的get请求\"><a class=\"anchor\" href=\"#cl不为0的get请求\">#</a> CL 不为 0 的 GET 请求</h2>\n<p>当前端服务器允许 GET 请求携带请求体，而后端服务器不允许 GET 请求携带请求体，它会直接忽略掉 GET 请求中的  <code>Content-Length</code>  头，不进行处理。例如下面这个例子：</p>\n<pre><code>GET / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\nContent-Length: 44\\r\\n\n\nGET /secret HTTP/1.1\\r\\n\nHost: example.com\\r\\n\n\\r\\n\n</code></pre>\n<p>前端服务器处理了  <code>Content-Length</code>  ，而后端服务器没有处理  <code>Content-Length</code>  ，基于 pipeline 机制认为这是两个独立的请求，就造成了漏洞的发生。</p>\n<h2 id=\"cl-cl\"><a class=\"anchor\" href=\"#cl-cl\">#</a> CL-CL</h2>\n<p>根据 RFC 7230，当服务器收到的请求中包含两个  <code>Content-Length</code>  ，而且两者的值不同时，需要返回 400 错误，但是有的服务器并没有严格实现这个规范。这种情况下，当前后端各取不同的  <code>Content-Length</code>  值时，就会出现漏洞。例如：</p>\n<pre><code>POST / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\nContent-Length: 8\\r\\n\nContent-Length: 7\\r\\n\n\n12345\\r\\n\na\n</code></pre>\n<p>这个例子中 a 就会被带入下一个请求，变为  <code>aGET / HTTP/1.1\\r\\n</code>  。</p>\n<h2 id=\"cl-te\"><a class=\"anchor\" href=\"#cl-te\">#</a> CL-TE</h2>\n<p>CL-TE 指前端服务器处理  <code>Content-Length</code>  这一请求头，而后端服务器遵守 RFC2616 的规定，忽略掉  <code>Content-Length</code>  ，处理  <code>Transfer-Encoding</code>  。例如：</p>\n<pre><code>POST / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\n...\nConnection: keep-alive\\r\\n\nContent-Length: 6\\r\\n\nTransfer-Encoding: chunked\\r\\n\n\\r\\n\n0\\r\\n\n\\r\\n\na\n</code></pre>\n<p>这个例子中 a 同样会被带入下一个请求，变为  <code>aGET / HTTP/1.1\\r\\n</code>  。</p>\n<h2 id=\"te-cl\"><a class=\"anchor\" href=\"#te-cl\">#</a> TE-CL</h2>\n<p>TE-CL 指前端服务器处理  <code>Transfer-Encoding</code>  请求头，而后端服务器处理  <code>Content-Length</code>  请求头。例如：</p>\n<pre><code>POST / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\n...\nContent-Length: 4\\r\\n\nTransfer-Encoding: chunked\\r\\n\n\\r\\n\n12\\r\\n\naPOST / HTTP/1.1\\r\\n\n\\r\\n\n0\\r\\n\n\\r\\n\n</code></pre>\n<h2 id=\"te-te\"><a class=\"anchor\" href=\"#te-te\">#</a> TE-TE</h2>\n<p>TE-TE 指前后端服务器都处理  <code>Transfer-Encoding</code>  请求头，但是在容错性上表现不同，例如有的服务器可能会处理  <code>Transfer-encoding</code>  ，测试例如：</p>\n<pre><code>POST / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\n...\nContent-length: 4\\r\\n\nTransfer-Encoding: chunked\\r\\n\nTransfer-encoding: cow\\r\\n\n\\r\\n\n5c\\r\\n\naPOST / HTTP/1.1\\r\\n\nContent-Type: application/x-www-form-urlencoded\\r\\n\nContent-Length: 15\\r\\n\n\\r\\n\nx=1\\r\\n\n0\\r\\n\n\\r\\n\n</code></pre>\n<h1 id=\"防御\"><a class=\"anchor\" href=\"#防御\">#</a> 防御</h1>\n<ul>\n<li>禁用后端连接重用</li>\n<li>确保连接中的所有服务器具有相同的配置</li>\n<li>拒绝有二义性的请求</li>\n</ul>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<h2 id=\"rfc\"><a class=\"anchor\" href=\"#rfc\">#</a> RFC</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTY=\">RFC 2616 Hypertext Transfer Protocol -- HTTP/1.1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzA=\">RFC 7230 Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing -- HTTP/1.1</span></li>\n</ul>\n<h2 id=\"blog-whitepaper\"><a class=\"anchor\" href=\"#blog-whitepaper\">#</a> Blog / Whitepaper</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2dpc2VjdXJpdHkuY29tL2xpYi9IVFRQLVJlcXVlc3QtU211Z2dsaW5nLnBkZg==\">HTTP Request Smuggling by chaiml</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wb3J0c3dpZ2dlci5uZXQvd2ViLXNlY3VyaXR5L3JlcXVlc3Qtc211Z2dsaW5n\">HTTP request smuggling by portswigger</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly94ei5hbGl5dW4uY29tL3QvNjY1NA==\">从一道题到协议层攻击之 HTTP 请求走私</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2kuYmxhY2toYXQuY29tL1VTQS0yMC9XZWRuZXNkYXkvdXMtMjAtS2xlaW4tSFRUUC1SZXF1ZXN0LVNtdWdnbGluZy1Jbi0yMDIwLU5ldy1WYXJpYW50cy1OZXctRGVmZW5zZXMtQW5kLU5ldy1DaGFsbGVuZ2VzLnBkZg==\">HTTP Request Smuggling in 2020</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sYWJzLmJpc2hvcGZveC5jb20vdGVjaC1ibG9nL2gyYy1zbXVnZ2xpbmctcmVxdWVzdC1zbXVnZ2xpbmctdmlhLWh0dHAvMi1jbGVhcnRleHQtaDJj\">h2c Smuggling: Request Smuggling Via HTTP/2 Cleartext (h2c)</span></li>\n</ul>\n",
            "tags": [
                "网络安全",
                "HTTP",
                "服务器"
            ]
        }
    ]
}