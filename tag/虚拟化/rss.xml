<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Khala • Posts by &#34;虚拟化&#34; tag</title>
        <link>https://mobius-0.github.io</link>
        <description>GLHF</description>
        <language>zh-CN</language>
        <pubDate>Tue, 29 Nov 2022 16:23:20 +0800</pubDate>
        <lastBuildDate>Tue, 29 Nov 2022 16:23:20 +0800</lastBuildDate>
        <category>Hexo</category>
        <category>shoya</category>
        <category>网站</category>
        <category>网络安全</category>
        <category>工具</category>
        <category>虚拟机</category>
        <category>安全</category>
        <category>星际争霸2</category>
        <category>平衡</category>
        <category>杂谈</category>
        <category>小说</category>
        <category>江南</category>
        <category>龙族</category>
        <category>动画</category>
        <category>法律法规</category>
        <category>XSS</category>
        <category>漏洞</category>
        <category>渗透测试</category>
        <category>靶场</category>
        <category>pikachu</category>
        <category>虚拟化</category>
        <category>Docker</category>
        <category>镜像</category>
        <category>标准</category>
        <category>OCI</category>
        <category>CRI</category>
        <category>域名</category>
        <category>DNS</category>
        <category>WEB</category>
        <category>HTTP</category>
        <category>计算机网络</category>
        <category>IPSec</category>
        <category>VPN</category>
        <category>SSL</category>
        <category>TLS</category>
        <category>WiFi</category>
        <category>邮件</category>
        <category>网络协议</category>
        <category>入侵检测</category>
        <category>IDS</category>
        <category>IPS</category>
        <category>防御加固</category>
        <category>管理策略</category>
        <category>分工</category>
        <category>职能</category>
        <category>情报</category>
        <category>运营</category>
        <category>开发过程</category>
        <category>应急响应</category>
        <category>流程</category>
        <category>Linux</category>
        <category>Windows</category>
        <category>攻击溯源</category>
        <category>分析模型</category>
        <category>网络攻防</category>
        <category>蜜罐</category>
        <category>隐藏</category>
        <category>诱导</category>
        <category>防御纵深</category>
        <category>访问控制</category>
        <category>过滤</category>
        <category>框架</category>
        <category>风险</category>
        <category>控制</category>
        <category>渗透</category>
        <category>信息收集</category>
        <category>痕迹清理</category>
        <category>内网</category>
        <category>后门</category>
        <category>免杀</category>
        <category>代理</category>
        <category>Shell</category>
        <category>远程连接</category>
        <category>ASP</category>
        <category>CSharp</category>
        <category>Golang</category>
        <category>Java</category>
        <category>语言</category>
        <category>反序列化</category>
        <category>混淆</category>
        <category>沙箱</category>
        <category>类</category>
        <category>JDK</category>
        <category>JavaScript</category>
        <category>PHP</category>
        <category>PowerShell</category>
        <category>Python</category>
        <category>Ruby</category>
        <category>CSRF</category>
        <category>服务器</category>
        <category>SQL注入</category>
        <category>SSRF</category>
        <category>Cache</category>
        <category>XXE</category>
        <category>XML</category>
        <category>Xpath</category>
        <category>注入</category>
        <category>函数</category>
        <category>绕过</category>
        <category>遍历</category>
        <category>包含</category>
        <category>文件</category>
        <category>目录</category>
        <category>读取</category>
        <category>上传</category>
        <category>中间件</category>
        <category>IIS</category>
        <category>Apache</category>
        <category>Nginx</category>
        <category>逻辑</category>
        <category>策略配置</category>
        <category>端口</category>
        <category>社会工程学</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://mobius-0.github.io/security/WebNote/Cloud%20Security/Docker/</guid>
            <title>Docker</title>
            <link>https://mobius-0.github.io/security/WebNote/Cloud%20Security/Docker/</link>
            <category>虚拟化</category>
            <category>Docker</category>
            <category>镜像</category>
            <pubDate>Tue, 29 Nov 2022 16:23:20 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;虚拟化技术与容器技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟化技术与容器技术&#34;&gt;#&lt;/a&gt; 虚拟化技术与容器技术&lt;/h1&gt;
&lt;h2 id=&#34;传统虚拟化技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#传统虚拟化技术&#34;&gt;#&lt;/a&gt; 传统虚拟化技术&lt;/h2&gt;
&lt;p&gt;传统虚拟化技术通过添加 hypervisor 层，虚拟出网卡，内存，CPU 等虚拟硬件，再在其上建立客户机，每个客户机都有自己的系统内核。传统虚拟化技术以虚拟机为管理单元，各虚拟机拥有独立的操作系统内核，不共用宿主机的软件系统资源，因此具有良好的隔离性，适用于云计算环境中的多租户场景。&lt;/p&gt;
&lt;h2 id=&#34;容器技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容器技术&#34;&gt;#&lt;/a&gt; 容器技术&lt;/h2&gt;
&lt;p&gt;容器技术可以看作一种轻量级的虚拟化方式，容器技术在操作系统层进行虚拟化，可在宿主机内核上运行多个虚拟化环境。相比于传统的应用测试与部署，容器的部署无需预先考虑应用的运行环境兼容性问题；相比于传统虚拟机，容器无需独立的操作系统内核就可在宿主机中运行，实现了更高的运行效率与资源利用率。&lt;/p&gt;
&lt;h1 id=&#34;docker&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker&#34;&gt;#&lt;/a&gt; Docker&lt;/h1&gt;
&lt;p&gt;Docker 是目前最具代表性的容器平台之一，具有持续部署与测试、跨云平台支持等优点。在基于 Kubernetes 等容器编排工具实现的容器云环境中，通过对跨主机集群资源的调度，容器云可提供资源共享与隔离、容器编排与部署、应用支撑等功能。&lt;/p&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本概念&#34;&gt;#&lt;/a&gt; 基本概念&lt;/h2&gt;
&lt;p&gt;Docker 有三个基本概念，镜像（Image）、容器（Container）、仓库（Repository）。镜像是一个只读的模版，由一组文件系统通过 Union FS 技术组成。&lt;/p&gt;
&lt;p&gt;镜像是静态的定义，容器是从镜像创建的运行实例。容器的本质是进程，拥有自己独立的命名空间。&lt;/p&gt;
&lt;p&gt;仓库（Repository） 是集中存放镜像文件的场所，用于存储、分发镜像。&lt;/p&gt;
&lt;p&gt;容器可以被启动、开始、停止、删除，每个容器都是相互隔离的，可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。&lt;/p&gt;
&lt;h2 id=&#34;组成&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组成&#34;&gt;#&lt;/a&gt; 组成&lt;/h2&gt;
&lt;p&gt;Docker 引擎由如下主要组件构成：Docker 客户端（Docker Client）、Docker 守护进程（Docker daemon）、containerd 以及 RunC，它们共同负责容器的创建和运行。&lt;/p&gt;
&lt;p&gt;Docker Client 是和 Docker Daemon 建立通信客户端，Docker Client 可以通过 http/unix socket 等方式 Daemon 建立通信。&lt;/p&gt;
&lt;p&gt;Docker Daemon 是容器管理的守护进程，在宿主机运行，作为服务端接受来自客户端的请求，主要功能包括镜像管理、镜像构建、REST API、身份验证、安全、核心网络以及编排。Docker daemon 通过位于  &lt;code&gt;/var/run/docker.sock&lt;/code&gt;  的本地 IPC/Unix socket 来实现 Docker 远程 API，默认非 TLS 网络端口为 2375，TLS 默认端口为 2376。&lt;/p&gt;
&lt;p&gt;containerd 是容器技术标准化之后出现的，用于将容器运行时从 Docker Daemon 剥离。containerd 主要职责是镜像管理、容器执行。&lt;/p&gt;
&lt;p&gt;RunC 是 Docker 按照 OCF 标准制定的一种具体实现，实现了容器启动与停止、资源隔离等功能。&lt;/p&gt;
&lt;h2 id=&#34;数据&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据&#34;&gt;#&lt;/a&gt; 数据&lt;/h2&gt;
&lt;p&gt;Docker 的数据主要分为持久化和非持久化数据，默认情况下非持久化存储是自动创建生命周期与容器相同，删除容器也会删除非持久化数据，在 Linux 环境下，非持久化数据默认存储于  &lt;code&gt;/var/lib/docker/&lt;/code&gt;  下。&lt;/p&gt;
&lt;h2 id=&#34;网络&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#网络&#34;&gt;#&lt;/a&gt; 网络&lt;/h2&gt;
&lt;p&gt;Docker 网络架构源自一种叫作容器网络模型的方案，主要由 CNM、Libnetwork、网络驱动构程。&lt;/p&gt;
&lt;h1 id=&#34;安全风险与安全机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#安全风险与安全机制&#34;&gt;#&lt;/a&gt; 安全风险与安全机制&lt;/h1&gt;
&lt;p&gt;在考虑 Docker 安全性的时候主要考虑以下几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核本身的安全性及其对命名空间和 cgroups 的支持&lt;/li&gt;
&lt;li&gt;Docker 守护进程本身的攻击面&lt;/li&gt;
&lt;li&gt;内核的 “强化” 安全功能以及它们如何与容器进行交互&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;docker安全基线&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker安全基线&#34;&gt;#&lt;/a&gt; Docker 安全基线&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://s2.loli.net/2022/11/29/Xd5eqSFysvYKQm1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;内核命名空间namespace&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内核命名空间namespace&#34;&gt;#&lt;/a&gt; 内核命名空间 /namespace&lt;/h2&gt;
&lt;p&gt;Docker 容器与 LXC 容器非常相似，并且具有相似的安全特性。当使用 docker 运行启动容器时，Docker 会在后台为容器创建一组命名空间和控制组。&lt;/p&gt;
&lt;p&gt;命名空间提供了一个最直接的隔离形式：在容器中运行的进程看不到或者无法影响在另一个容器或主机系统中运行的进程。&lt;/p&gt;
&lt;p&gt;每个容器也有自己的网络堆栈，这意味着一个容器不能获得对另一个容器的套接字或接口的特权访问。当然，如果主机系统相应设置，容器可以通过各自的网络接口交互。如果为容器指定公共端口或使用链接时，容器之间允许 IP 通信。&lt;/p&gt;
&lt;p&gt;它们可以相互 ping 通，发送 / 接收 UDP 数据包，并建立 TCP 连接，但是如果需要可以限制它们。从网络体系结构的角度来看，给定 Docker 主机上的所有容器都位于网桥接口上。这意味着它们就像通过普通的以太网交换机连接的物理机器一样。&lt;/p&gt;
&lt;h2 id=&#34;control-group&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#control-group&#34;&gt;#&lt;/a&gt; Control Group&lt;/h2&gt;
&lt;p&gt;控制组是 Linux 容器的另一个关键组件，主要作用是实施资源核算和限制。&lt;/p&gt;
&lt;p&gt;Cgroup 提供了许多有用的度量标准，但也有助于确保每个容器都能获得公平的内存，CPU 和磁盘 I/O; 更重要的是单个容器不能通过耗尽资源的方式来降低系统的性能。&lt;/p&gt;
&lt;p&gt;因此，尽管 Cgroup 不能阻止一个容器访问或影响另一个容器的数据和进程，但它们对于抵御一些拒绝服务攻击是至关重要的。它们对于多租户平台尤其重要，例如公共和私人 PaaS，即使在某些应用程序开始行为不当时也能保证一致的正常运行时间（和性能）。&lt;/p&gt;
&lt;h2 id=&#34;守护进程的攻击面&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#守护进程的攻击面&#34;&gt;#&lt;/a&gt; 守护进程的攻击面&lt;/h2&gt;
&lt;p&gt;使用 Docker 运行容器意味着运行 Docker 守护进程，而这个守护进程当前需要 root 权限，因此，守护进程是需要考虑的一个地方。&lt;/p&gt;
&lt;p&gt;首先，只有受信任的用户才能被允许控制 Docker 守护进程。具体来说，Docker 允许您在 Docker 主机和访客容器之间共享一个目录；它允许你这样做而不限制容器的访问权限。这意味着可以启动一个容器，其中 /host 目录将成为主机上的 / 目录，容器将能够不受任何限制地改变主机文件系统。&lt;/p&gt;
&lt;p&gt;这具有很强的安全意义：例如，如果通过 Web 服务器测试 Docker 以通过 API 配置容器，则应该更加仔细地进行参数检查，以确保恶意用户无法传递制作的参数，从而导致 Docker 创建任意容器。&lt;/p&gt;
&lt;p&gt;守护进程也可能容易受到其他输入的影响，例如从具有 docker 负载的磁盘或从具有 docker pull 的网络加载映像。&lt;/p&gt;
&lt;p&gt;最终，预计 Docker 守护进程将运行受限特权，将操作委托给审核良好的子进程，每个子进程都有自己的（非常有限的）Linux 功能范围，虚拟网络设置，文件系统管理等。也就是说，很可能，Docker 引擎本身的部分将在容器中运行。&lt;/p&gt;
&lt;h2 id=&#34;capability&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#capability&#34;&gt;#&lt;/a&gt; Capability&lt;/h2&gt;
&lt;p&gt;默认情况下，Docker 采用 Capability 机制来实现用户在以 root 身份运行容器的同时，限制部分 root 的操作。&lt;/p&gt;
&lt;p&gt;在大多数情况下，容器不需要真正的 root 权限。因此，Docker 可以运行一个 Capability 较低的集合，这意味着容器中的 root 比真正的 root 要少得多。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;否认所有挂载操作&lt;/li&gt;
&lt;li&gt;拒绝访问原始套接字（防止数据包欺骗）&lt;/li&gt;
&lt;li&gt;拒绝访问某些文件系统操作，如创建新的设备节点，更改文件的所有者或修改属性（包括不可变标志）&lt;/li&gt;
&lt;li&gt;拒绝模块加载&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着，即使入侵者在容器内获取 root 权限，进一步攻击也会困难很多。默认情况下，Docker 使用白名单而不是黑名单，去除了所有非必要的功能。&lt;/p&gt;
&lt;h2 id=&#34;seccomp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#seccomp&#34;&gt;#&lt;/a&gt; Seccomp&lt;/h2&gt;
&lt;p&gt;Docker 使用 Seccomp 来限制容器对宿主机内核发起的系统调用。&lt;/p&gt;
&lt;h1 id=&#34;攻击面分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#攻击面分析&#34;&gt;#&lt;/a&gt; 攻击面分析&lt;/h1&gt;
&lt;h2 id=&#34;供应链安全&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#供应链安全&#34;&gt;#&lt;/a&gt; 供应链安全&lt;/h2&gt;
&lt;p&gt;在构建 Dockerfile 的过程中，即使是使用排名靠前的来源，也可能存在 CVE 漏洞、后门、镜像被污染、镜像中的依赖库存在漏洞等问题。&lt;/p&gt;
&lt;h2 id=&#34;虚拟化风险&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟化风险&#34;&gt;#&lt;/a&gt; 虚拟化风险&lt;/h2&gt;
&lt;p&gt;虽然 Docker 通过命名空间进行了文件系统资源的基本隔离，但仍有  &lt;code&gt;/sys&lt;/code&gt;  、 &lt;code&gt;/proc/sys&lt;/code&gt;  、  &lt;code&gt;/proc/bus&lt;/code&gt;  、  &lt;code&gt;/dev&lt;/code&gt;  、 &lt;code&gt;time&lt;/code&gt;  、 &lt;code&gt;syslog&lt;/code&gt;  等重要系统文件目录和命名空间信息未实现隔离，而是与宿主机共享相关资源。&lt;/p&gt;
&lt;h2 id=&#34;利用内核漏洞逃逸&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#利用内核漏洞逃逸&#34;&gt;#&lt;/a&gt; 利用内核漏洞逃逸&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CVE-2022-0847 Dirty Pipe&lt;/li&gt;
&lt;li&gt;CVE-2021-4034 Polkit&lt;/li&gt;
&lt;li&gt;CVE-2018-18955&lt;/li&gt;
&lt;li&gt;CVE-2016-5195&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;容器逃逸漏洞&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容器逃逸漏洞&#34;&gt;#&lt;/a&gt; 容器逃逸漏洞&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CVE-2021-41091&lt;/li&gt;
&lt;li&gt;CVE-2020-15257 Containerd 逃逸
&lt;ul&gt;
&lt;li&gt;需要网络设置为 host 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CVE-2019-14271 Docker cp&lt;/li&gt;
&lt;li&gt;CVE-2019-13139 Docker build code execution&lt;/li&gt;
&lt;li&gt;CVE-2019-5736 runC
&lt;ul&gt;
&lt;li&gt;Docker Version &amp;lt; 18.09.2&lt;/li&gt;
&lt;li&gt;Version &amp;lt;= 1.0-rc6&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置不当&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置不当&#34;&gt;#&lt;/a&gt; 配置不当&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;开启 privileged&lt;/li&gt;
&lt;li&gt;挂载宿主机敏感目录&lt;/li&gt;
&lt;li&gt;配置 cap 不当
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--cap-add=SYS_ADMIN&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;绕过 namespace
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--net=host&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--pid=host&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--ipc=host&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拒绝服务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#拒绝服务&#34;&gt;#&lt;/a&gt; 拒绝服务&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU 耗尽&lt;/li&gt;
&lt;li&gt;内存耗尽&lt;/li&gt;
&lt;li&gt;存储耗尽&lt;/li&gt;
&lt;li&gt;网络资源耗尽&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;危险挂载&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#危险挂载&#34;&gt;#&lt;/a&gt; 危险挂载&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;挂载  &lt;code&gt;/var/run/docker.sock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;挂载宿主机  &lt;code&gt;/dev&lt;/code&gt;   &lt;code&gt;/proc&lt;/code&gt;  等危险目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;攻击-docker-守护进程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#攻击-docker-守护进程&#34;&gt;#&lt;/a&gt; 攻击 Docker 守护进程&lt;/h2&gt;
&lt;p&gt;虽然 Docker 容器具有很强的安全保护措施，但是 Docker 守护进程本身并没有被完善的保护。Docker 守护进程本身默认由 root 用户运行，并且该进程本身并没有使用 Seccomp 或者 AppArmor 等安全模块进行保护。这使得一旦攻击者成功找到漏洞控制 Docker 守护进程进行任意文件写或者代码执行，就可以顺利获得宿主机的 root 权限而不会受到各种安全机制的阻碍。值得一提的是，默认情况下 Docker 不会开启 User Namespace 隔离，这也意味着 Docker 内部的 root 与宿主机 root 对文件的读写权限相同。这导致一旦容器内部 root 进程获取读写宿主机文件的机会，文件权限将不会成为另一个问题。这一点在 CVE-2019-5636 利用中有所体现。&lt;/p&gt;
&lt;h2 id=&#34;其他cve&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他cve&#34;&gt;#&lt;/a&gt; 其他 CVE&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CVE-2014-5277&lt;/li&gt;
&lt;li&gt;CVE-2014-6408&lt;/li&gt;
&lt;li&gt;CVE-2014-9357&lt;/li&gt;
&lt;li&gt;CVE-2014-9358&lt;/li&gt;
&lt;li&gt;CVE-2015-3627&lt;/li&gt;
&lt;li&gt;CVE-2015-3630&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;安全加固&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#安全加固&#34;&gt;#&lt;/a&gt; 安全加固&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;最小安装
&lt;ul&gt;
&lt;li&gt;删除所有开发工具（编译器等）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新系统源&lt;/li&gt;
&lt;li&gt;启用 AppArmor&lt;/li&gt;
&lt;li&gt;启用 SELinux&lt;/li&gt;
&lt;li&gt;限制运行容器的内核功能&lt;/li&gt;
&lt;li&gt;移除依赖构建&lt;/li&gt;
&lt;li&gt;配置严格的网络访问控制策略&lt;/li&gt;
&lt;li&gt;不使用 root 用户启动 docker&lt;/li&gt;
&lt;li&gt;不以 privileged 特权模式运行容器&lt;/li&gt;
&lt;li&gt;控制资源
&lt;ul&gt;
&lt;li&gt;CPU Share&lt;/li&gt;
&lt;li&gt;CPU 核数&lt;/li&gt;
&lt;li&gt;内存资源&lt;/li&gt;
&lt;li&gt;IO 资源&lt;/li&gt;
&lt;li&gt;磁盘资源&lt;/li&gt;
&lt;li&gt;硬件资源&lt;/li&gt;
&lt;li&gt;单位时间内进程数量上限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用安全的基础镜像&lt;/li&gt;
&lt;li&gt;定期安全扫描和更新补丁&lt;/li&gt;
&lt;li&gt;删除镜像中的 setuid 和 setgid 权限
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RUN find / -perm +6000-type f-exec chmod a-s &amp;#123;&amp;#125; \;|| true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置 Docker 守护程序的 TLS 身份验证&lt;/li&gt;
&lt;li&gt;如非必要 禁止容器间通信&lt;/li&gt;
&lt;li&gt;rootless Docker
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9nZXQuZG9ja2VyLmNvbS9yb290bGVzcw==&#34;&gt;https://get.docker.com/rootless&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 Seccomp 限制 syscall&lt;/li&gt;
&lt;li&gt;构建环境和在线环境分开&lt;/li&gt;
&lt;li&gt;证书校验&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;docker-环境识别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-环境识别&#34;&gt;#&lt;/a&gt; Docker 环境识别&lt;/h1&gt;
&lt;h2 id=&#34;docker内&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker内&#34;&gt;#&lt;/a&gt; Docker 内&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MAC 地址为  &lt;code&gt;02:42:ac:11:00:00&lt;/code&gt;  -  &lt;code&gt;02:42:ac:11:ff:ff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ps aux&lt;/code&gt;  大部分运行的程序 pid 都很小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat /proc/1/cgroup&lt;/code&gt;  docker 的进程&lt;/li&gt;
&lt;li&gt;docker 环境下存在  &lt;code&gt;.dockerenv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;部分容器中缺少许多常用的命令如  &lt;code&gt;ping&lt;/code&gt;  等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;docker外&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker外&#34;&gt;#&lt;/a&gt; Docker 外&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/var/run/docker.sock&lt;/code&gt;  文件存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2375&lt;/code&gt;  /  &lt;code&gt;2376&lt;/code&gt;  端口开启&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;容器内信息收集&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容器内信息收集&#34;&gt;#&lt;/a&gt; 容器内信息收集&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;用户信息 (当前用户、用户列表)&lt;/li&gt;
&lt;li&gt;操作系统与内核版本&lt;/li&gt;
&lt;li&gt;运行进程信息 (进程名、权限等)&lt;/li&gt;
&lt;li&gt;容器是否为特权容器&lt;/li&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;li&gt;判断容器挂载信息，尝试挂载 Docker Socket&lt;/li&gt;
&lt;li&gt;网络环境，判断可以到达的网段&lt;/li&gt;
&lt;li&gt;在云环境中，尝试获取元数据信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;镜像&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#镜像&#34;&gt;#&lt;/a&gt; 镜像&lt;/h1&gt;
&lt;h2 id=&#34;基本概念-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本概念-2&#34;&gt;#&lt;/a&gt; 基本概念&lt;/h2&gt;
&lt;p&gt;Docker 镜像可以看作是一个特殊的文件系统，用于提供容器运行时所需的文件，同时镜像还包含了一些为运行时准备的一些信息（环境变量、用户等）。&lt;/p&gt;
&lt;p&gt;在构建之后镜像不会被改变，即是说镜像中不会包含动态的数据。&lt;/p&gt;
&lt;h2 id=&#34;windows-镜像&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#windows-镜像&#34;&gt;#&lt;/a&gt; Windows 镜像&lt;/h2&gt;
&lt;p&gt;由于 Windows 并不直接开放 syscall ，所有的 Windows 程序都必须通过 sys dll 与内核沟通，这就导致 Windows 镜像并不能直接通过 scratch 来构建，只能基于微软提供的几个基础镜像来构建。&lt;/p&gt;
&lt;p&gt;镜像包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fL21pY3Jvc29mdC13aW5kb3dzLXNlcnZlcmNvcmU=&#34;&gt;windows servercore&lt;/span&gt; 功能最完整，包含传统的 .net framework 环境&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fL21pY3Jvc29mdC13aW5kb3dzLW5hbm9zZXJ2ZXI=&#34;&gt;windows nanoserver&lt;/span&gt; 包含 .net core 运行环境&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fL21pY3Jvc29mdC13aW5kb3dz&#34;&gt;windows&lt;/span&gt; 提供完整的 windows server api，正在被 windows server 替代&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fL21pY3Jvc29mdC13aW5kb3dzLXNlcnZlci8=&#34;&gt;windows server&lt;/span&gt; 提供完整的 windows server api&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考链接&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#参考链接&#34;&gt;#&lt;/a&gt; 参考链接&lt;/h1&gt;
&lt;h2 id=&#34;安全分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#安全分析&#34;&gt;#&lt;/a&gt; 安全分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmhlcm9rdS5jb20vZXhwbG9yYXRpb24tb2Ytc2VjdXJpdHktd2hlbi1idWlsZGluZy1kb2NrZXItY29udGFpbmVycw==&#34;&gt;A House of Cards An Exploration of Security When Building Docker Containers&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL29icm93bi5pby8yMDE2LzAyLzE1L3ByaXZpbGVnZWQtY29udGFpbmVycy5odG1s&#34;&gt;Privileged Docker Containers&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9raXRjdGYuZGUvd3JpdGV1cHMvMzJjM2N0Zi9kb2NrZXI=&#34;&gt;32c3 docker writeup&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLnFpbml1LmNvbS9hcmNoaXZlcy83NzQz&#34;&gt;打造安全的容器云平台&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3NlY3VyaXR5L3NlY3VyaXR5Lw==&#34;&gt;Docker security&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2Jsb2cubnNmb2N1cy5uZXQvZG9ja2VyLW1pcnJvci1zZWN1cml0eS8=&#34;&gt;容器安全&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zdHJtLnNoL3Bvc3QvYWJ1c2luZy1pbnNlY3VyZS1kb2NrZXItZGVwbG95bWVudHMv&#34;&gt;CVE-2017-7494 Docker 沙箱逃逸&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvc3lzdGVtLzIyMTMxOS5odG1s&#34;&gt;Docker 容器安全性分析&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3NlY3VyaXR5L2FwcGFybW9yLw==&#34;&gt;AppArmor security profiles for Docker&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9kb2NrZXItYmVuY2gtc2VjdXJpdHk=&#34;&gt;Docker Bench for Security&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZDlEM3oxM3VDT0pvSnpwbHB1M1dKUQ==&#34;&gt;Docker 安全性与攻击面分析&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Pfleeger C P , Pfleeger S L , Theofanos M F . A methodology for penetration testing[J]. Computers &amp;amp; Security, 1989, 8(7):613-620.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;windows&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#windows&#34;&gt;#&lt;/a&gt; Windows&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL3ZpcnR1YWxpemF0aW9uL3dpbmRvd3Njb250YWluZXJzL21hbmFnZS1jb250YWluZXJzL2NvbnRhaW5lci1iYXNlLWltYWdlcw==&#34;&gt;Container Base Images&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
