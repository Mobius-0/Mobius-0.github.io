{
    "version": "https://jsonfeed.org/version/1",
    "title": "Khala • All posts by \"http\" tag",
    "description": "GLHF",
    "home_page_url": "https://mobius-0.github.io",
    "items": [
        {
            "id": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/HTTP%20request/",
            "url": "https://mobius-0.github.io/security/WebNote/Vulnerability%20Attack%20and%20defense/HTTP%20request/",
            "title": "HTTP请求走私",
            "date_published": "2022-11-27T07:47:26.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>HTTP 请求走私是一种干扰网站处理 HTTP 请求序列方式的技术，最早在 2005 年的一篇 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2dpc2VjdXJpdHkuY29tL2xpYi9IVFRQLVJlcXVlc3QtU211Z2dsaW5nLnBkZg==\">文章</span> 中被提出。</p>\n<h1 id=\"成因\"><a class=\"anchor\" href=\"#成因\">#</a> 成因</h1>\n<p>请求走私大多发生于前端服务器和后端服务器对客户端传入的数据理解不一致的情况。这是因为 HTTP 规范提供了两种不同的方法来指定请求的结束位置，即  <code>Content-Length</code>  和  <code>Transfer-Encoding</code>  标头。</p>\n<h1 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类</h1>\n<ul>\n<li>CLTE：前端服务器使用  <code>Content-Length</code>  头，后端服务器使用  <code>Transfer-Encoding</code>  头</li>\n<li>TECL：前端服务器使用  <code>Transfer-Encoding</code>  标头，后端服务器使用  <code>Content-Length</code>  标头。</li>\n<li>TETE：前端和后端服务器都支持  <code>Transfer-Encoding</code>  标头，但是可以通过以某种方式来诱导其中一个服务器不处理它。</li>\n</ul>\n<h1 id=\"攻击\"><a class=\"anchor\" href=\"#攻击\">#</a> 攻击</h1>\n<h2 id=\"cl不为0的get请求\"><a class=\"anchor\" href=\"#cl不为0的get请求\">#</a> CL 不为 0 的 GET 请求</h2>\n<p>当前端服务器允许 GET 请求携带请求体，而后端服务器不允许 GET 请求携带请求体，它会直接忽略掉 GET 请求中的  <code>Content-Length</code>  头，不进行处理。例如下面这个例子：</p>\n<pre><code>GET / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\nContent-Length: 44\\r\\n\n\nGET /secret HTTP/1.1\\r\\n\nHost: example.com\\r\\n\n\\r\\n\n</code></pre>\n<p>前端服务器处理了  <code>Content-Length</code>  ，而后端服务器没有处理  <code>Content-Length</code>  ，基于 pipeline 机制认为这是两个独立的请求，就造成了漏洞的发生。</p>\n<h2 id=\"cl-cl\"><a class=\"anchor\" href=\"#cl-cl\">#</a> CL-CL</h2>\n<p>根据 RFC 7230，当服务器收到的请求中包含两个  <code>Content-Length</code>  ，而且两者的值不同时，需要返回 400 错误，但是有的服务器并没有严格实现这个规范。这种情况下，当前后端各取不同的  <code>Content-Length</code>  值时，就会出现漏洞。例如：</p>\n<pre><code>POST / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\nContent-Length: 8\\r\\n\nContent-Length: 7\\r\\n\n\n12345\\r\\n\na\n</code></pre>\n<p>这个例子中 a 就会被带入下一个请求，变为  <code>aGET / HTTP/1.1\\r\\n</code>  。</p>\n<h2 id=\"cl-te\"><a class=\"anchor\" href=\"#cl-te\">#</a> CL-TE</h2>\n<p>CL-TE 指前端服务器处理  <code>Content-Length</code>  这一请求头，而后端服务器遵守 RFC2616 的规定，忽略掉  <code>Content-Length</code>  ，处理  <code>Transfer-Encoding</code>  。例如：</p>\n<pre><code>POST / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\n...\nConnection: keep-alive\\r\\n\nContent-Length: 6\\r\\n\nTransfer-Encoding: chunked\\r\\n\n\\r\\n\n0\\r\\n\n\\r\\n\na\n</code></pre>\n<p>这个例子中 a 同样会被带入下一个请求，变为  <code>aGET / HTTP/1.1\\r\\n</code>  。</p>\n<h2 id=\"te-cl\"><a class=\"anchor\" href=\"#te-cl\">#</a> TE-CL</h2>\n<p>TE-CL 指前端服务器处理  <code>Transfer-Encoding</code>  请求头，而后端服务器处理  <code>Content-Length</code>  请求头。例如：</p>\n<pre><code>POST / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\n...\nContent-Length: 4\\r\\n\nTransfer-Encoding: chunked\\r\\n\n\\r\\n\n12\\r\\n\naPOST / HTTP/1.1\\r\\n\n\\r\\n\n0\\r\\n\n\\r\\n\n</code></pre>\n<h2 id=\"te-te\"><a class=\"anchor\" href=\"#te-te\">#</a> TE-TE</h2>\n<p>TE-TE 指前后端服务器都处理  <code>Transfer-Encoding</code>  请求头，但是在容错性上表现不同，例如有的服务器可能会处理  <code>Transfer-encoding</code>  ，测试例如：</p>\n<pre><code>POST / HTTP/1.1\\r\\n\nHost: example.com\\r\\n\n...\nContent-length: 4\\r\\n\nTransfer-Encoding: chunked\\r\\n\nTransfer-encoding: cow\\r\\n\n\\r\\n\n5c\\r\\n\naPOST / HTTP/1.1\\r\\n\nContent-Type: application/x-www-form-urlencoded\\r\\n\nContent-Length: 15\\r\\n\n\\r\\n\nx=1\\r\\n\n0\\r\\n\n\\r\\n\n</code></pre>\n<h1 id=\"防御\"><a class=\"anchor\" href=\"#防御\">#</a> 防御</h1>\n<ul>\n<li>禁用后端连接重用</li>\n<li>确保连接中的所有服务器具有相同的配置</li>\n<li>拒绝有二义性的请求</li>\n</ul>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<h2 id=\"rfc\"><a class=\"anchor\" href=\"#rfc\">#</a> RFC</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTY=\">RFC 2616 Hypertext Transfer Protocol -- HTTP/1.1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzA=\">RFC 7230 Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing -- HTTP/1.1</span></li>\n</ul>\n<h2 id=\"blog-whitepaper\"><a class=\"anchor\" href=\"#blog-whitepaper\">#</a> Blog / Whitepaper</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2dpc2VjdXJpdHkuY29tL2xpYi9IVFRQLVJlcXVlc3QtU211Z2dsaW5nLnBkZg==\">HTTP Request Smuggling by chaiml</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wb3J0c3dpZ2dlci5uZXQvd2ViLXNlY3VyaXR5L3JlcXVlc3Qtc211Z2dsaW5n\">HTTP request smuggling by portswigger</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly94ei5hbGl5dW4uY29tL3QvNjY1NA==\">从一道题到协议层攻击之 HTTP 请求走私</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2kuYmxhY2toYXQuY29tL1VTQS0yMC9XZWRuZXNkYXkvdXMtMjAtS2xlaW4tSFRUUC1SZXF1ZXN0LVNtdWdnbGluZy1Jbi0yMDIwLU5ldy1WYXJpYW50cy1OZXctRGVmZW5zZXMtQW5kLU5ldy1DaGFsbGVuZ2VzLnBkZg==\">HTTP Request Smuggling in 2020</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sYWJzLmJpc2hvcGZveC5jb20vdGVjaC1ibG9nL2gyYy1zbXVnZ2xpbmctcmVxdWVzdC1zbXVnZ2xpbmctdmlhLWh0dHAvMi1jbGVhcnRleHQtaDJj\">h2c Smuggling: Request Smuggling Via HTTP/2 Cleartext (h2c)</span></li>\n</ul>\n",
            "tags": [
                "网络安全",
                "HTTP",
                "服务器"
            ]
        },
        {
            "id": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/HTTP/",
            "url": "https://mobius-0.github.io/security/WebNote/Computer%20Network%20and%20Protocol/HTTP/",
            "title": "HTTP协议簇",
            "date_published": "2022-11-25T03:05:41.000Z",
            "content_html": "<h1 id=\"http标准\"><a class=\"anchor\" href=\"#http标准\">#</a> HTTP 标准</h1>\n<h2 id=\"报文格式\"><a class=\"anchor\" href=\"#报文格式\">#</a> 报文格式</h2>\n<h3 id=\"请求报文格式\"><a class=\"anchor\" href=\"#请求报文格式\">#</a> 请求报文格式</h3>\n<figure class=\"highlight http\"><figcaption data-lang=\"HTTP\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>&lt;method>&lt;request-URL>&lt;version></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>&lt;headers></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>&lt;entity-body></pre></td></tr></table></figure><h3 id=\"响应报文格式\"><a class=\"anchor\" href=\"#响应报文格式\">#</a> 响应报文格式</h3>\n<figure class=\"highlight http\"><figcaption data-lang=\"HTTP\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>&lt;version>&lt;status>&lt;reason-phrase></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>&lt;headers></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>&lt;entity-body></pre></td></tr></table></figure><h3 id=\"字段解释\"><a class=\"anchor\" href=\"#字段解释\">#</a> 字段解释</h3>\n<ul>\n<li>method\n<ul>\n<li>HTTP 动词</li>\n<li>常见方法：HEAD / GET / POST / PUT / DELETE / PATCH / OPTIONS / TRACE</li>\n<li>扩展方法：LOCK / MKCOL / COPY / MOVE</li>\n</ul>\n</li>\n<li>version\n<ul>\n<li>报文使用的 HTTP 版本</li>\n<li>格式为 HTTP/&lt;major&gt;.&lt;minor&gt;</li>\n</ul>\n</li>\n<li>url\n<ul>\n<li><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"请求头列表\"><a class=\"anchor\" href=\"#请求头列表\">#</a> 请求头列表</h2>\n<ul>\n<li>Accept\n<ul>\n<li>指定客户端能够接收的内容类型</li>\n<li>Accept: text/plain, text/html</li>\n</ul>\n</li>\n<li>Accept-Charset\n<ul>\n<li>浏览器可以接受的字符编码集</li>\n<li>Accept-Charset: iso-8859-5</li>\n</ul>\n</li>\n<li>Accept-Encoding\n<ul>\n<li>指定浏览器可以支持的 web 服务器返回内容压缩编码类型</li>\n<li>Accept-Encoding: compress, gzip</li>\n</ul>\n</li>\n<li>Accept-Language\n<ul>\n<li>浏览器可接受的语言</li>\n<li>Accept-Language: en,zh</li>\n</ul>\n</li>\n<li>Accept-Ranges\n<ul>\n<li>可以请求网页实体的一个或者多个子范围字段</li>\n<li>Accept-Ranges: bytes</li>\n</ul>\n</li>\n<li>Authorization\n<ul>\n<li>HTTP 授权的授权证书</li>\n<li>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</li>\n</ul>\n</li>\n<li>Cache-Control\n<ul>\n<li>指定请求和响应遵循的缓存机制 Cache-Control: no-cache</li>\n</ul>\n</li>\n<li>Connection\n<ul>\n<li>表示是否需要持久连接 // HTTP 1.1 默认进行持久连接</li>\n<li>Connection: close</li>\n</ul>\n</li>\n<li>Cookie\n<ul>\n<li>HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器</li>\n<li>Cookie: role=admin;ssid=1</li>\n</ul>\n</li>\n<li>Content-Length\n<ul>\n<li>请求的内容长度</li>\n<li>Content-Length: 348</li>\n</ul>\n</li>\n<li>Content-Type\n<ul>\n<li>请求的与实体对应的 MIME 信息</li>\n<li>Content-Type: application/x-www-form-urlencoded</li>\n</ul>\n</li>\n<li>Date\n<ul>\n<li>请求发送的日期和时间</li>\n<li>Date: Tue, 15 Nov 2010 08:12:31 GMT</li>\n</ul>\n</li>\n<li>Expect\n<ul>\n<li>请求的特定的服务器行为</li>\n<li>Expect: 100-continue</li>\n</ul>\n</li>\n<li>From\n<ul>\n<li>发出请求的用户的</li>\n<li>EmailFrom: <span class=\"exturl\" data-url=\"bWFpbHRvOnVzZXJAZW1haWwuY29t\">user@email.com</span></li>\n</ul>\n</li>\n<li>Host\n<ul>\n<li>指定请求的服务器的域名和端口号</li>\n<li>Host: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5naXRodWIuY29t\">www.github.com</span></li>\n</ul>\n</li>\n<li>If-Match\n<ul>\n<li>只有请求内容与实体相匹配才有效</li>\n<li>If-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</li>\n</ul>\n</li>\n<li>If-Modified-Since\n<ul>\n<li>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回 304 代码</li>\n<li>If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT</li>\n</ul>\n</li>\n<li>If-None-Match\n<ul>\n<li>如果内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改变</li>\n<li>If-None-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</li>\n</ul>\n</li>\n<li>If-Range\n<ul>\n<li>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为 Etag</li>\n<li>If-Range: &quot;737060cd8c284d8af7ad3082f209582d&quot;</li>\n</ul>\n</li>\n<li>If-Unmodified-Since\n<ul>\n<li>只在实体在指定时间之后未被修改才请求成功</li>\n<li>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</li>\n</ul>\n</li>\n<li>Max-Forwards\n<ul>\n<li>限制信息通过代理和网关传送的时间</li>\n<li>Max-Forwards: 10</li>\n</ul>\n</li>\n<li>Pragma\n<ul>\n<li>用来包含实现特定的指令</li>\n<li>Pragma: no-cache</li>\n</ul>\n</li>\n<li>Proxy-Authorization\n<ul>\n<li>连接到代理的授权证书</li>\n<li>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</li>\n</ul>\n</li>\n<li>Range\n<ul>\n<li>只请求实体的一部分，指定范围</li>\n<li>Range: bytes=500-999</li>\n</ul>\n</li>\n<li>Referer\n<ul>\n<li>先前网页的地址，当前请求网页紧随其后，即来路</li>\n<li>Referer: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvNzEuaHRtbA==\">http://www.zcmhi.com/archives/71.html</span></li>\n</ul>\n</li>\n<li>TE\n<ul>\n<li>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</li>\n<li>TE: trailers,deflate;q=0.5</li>\n</ul>\n</li>\n<li>Upgrade\n<ul>\n<li>向服务器指定某种传输协议以便服务器进行转换（如果支持）</li>\n<li>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</li>\n</ul>\n</li>\n<li>User-Agent\n<ul>\n<li>User-Agent 的内容包含发出请求的用户信息</li>\n<li>User-Agent: Mozilla/5.0 (Linux; X11)</li>\n</ul>\n</li>\n<li>Via\n<ul>\n<li>通知中间网关或代理服务器地址，通信协议</li>\n<li>Via: 1.0 fred, 1.1 <span class=\"exturl\" data-url=\"aHR0cDovL25vd2hlcmUuY29t\">nowhere.com</span> (Apache/1.1)</li>\n</ul>\n</li>\n<li>Warning\n<ul>\n<li>关于消息实体的警告信息</li>\n<li>Warn: 199 Miscellaneous warning</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"响应头列表\"><a class=\"anchor\" href=\"#响应头列表\">#</a> 响应头列表</h2>\n<ul>\n<li>Accept-Ranges\n<ul>\n<li>表明服务器是否支持指定范围请求及哪种类型的分段请求</li>\n<li>Accept-Ranges: bytes</li>\n</ul>\n</li>\n<li>Access-Control-Allow-Origin\n<ul>\n<li>配置有权限访问资源的域</li>\n<li>Access-Control-Allow-Origin: &lt;origin&gt;|*</li>\n</ul>\n</li>\n<li>Age\n<ul>\n<li>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</li>\n<li>Age: 12</li>\n</ul>\n</li>\n<li>Allow\n<ul>\n<li>对某网络资源的有效的请求行为，不允许则返回 405</li>\n<li>Allow: GET, HEAD</li>\n</ul>\n</li>\n<li>Cache-Control\n<ul>\n<li>告诉所有的缓存机制是否可以缓存及哪种类型</li>\n<li>Cache-Control: no-cache</li>\n</ul>\n</li>\n<li>Content-Encoding\n<ul>\n<li>web 服务器支持的返回内容压缩编码类型</li>\n<li>Content-Encoding: gzip</li>\n</ul>\n</li>\n<li>Content-Language\n<ul>\n<li>响应体的语言</li>\n<li>Content-Language: en,zh</li>\n</ul>\n</li>\n<li>Content-Length\n<ul>\n<li>响应体的长度</li>\n<li>Content-Length: 348</li>\n</ul>\n</li>\n<li>Content-Location\n<ul>\n<li>请求资源可替代的备用的另一地址</li>\n<li>Content-Location: /index.htm</li>\n</ul>\n</li>\n<li>Content-MD5\n<ul>\n<li>返回资源的 MD5 校验值</li>\n<li>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</li>\n</ul>\n</li>\n<li>Content-Range\n<ul>\n<li>在整个返回体中本部分的字节位置</li>\n<li>Content-Range: bytes 21010-47021/47022</li>\n</ul>\n</li>\n<li>Content-Type\n<ul>\n<li>返回内容的 MIME 类型</li>\n<li>Content-Type: text/html; charset=utf-8</li>\n</ul>\n</li>\n<li>Date\n<ul>\n<li>原始服务器消息发出的时间</li>\n<li>Date: Tue, 15 Nov 2010 08:12:31 GMT</li>\n</ul>\n</li>\n<li>ETag\n<ul>\n<li>请求变量的实体标签的当前值</li>\n<li>ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</li>\n</ul>\n</li>\n<li>Expires\n<ul>\n<li>响应过期的日期和时间</li>\n<li>Expires: Thu, 01 Dec 2010 16:00:00 GMT</li>\n</ul>\n</li>\n<li>Last-Modified\n<ul>\n<li>请求资源的最后修改时间</li>\n<li>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</li>\n</ul>\n</li>\n<li>Location\n<ul>\n<li>用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源</li>\n<li>Location: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvOTQuaHRtbA==\">http://www.zcmhi.com/archives/94.html</span></li>\n</ul>\n</li>\n<li>Pragma\n<ul>\n<li>包括实现特定的指令，它可应用到响应链上的任何接收方</li>\n<li>Pragma: no-cache</li>\n</ul>\n</li>\n<li>Proxy-Authenticate\n<ul>\n<li>它指出认证方案和可应用到代理的该 URL 上的参数</li>\n<li>Proxy-Authenticate: Basic</li>\n</ul>\n</li>\n<li>Refresh\n<ul>\n<li>应用于重定向或一个新的资源被创造，在 5 秒之后重定向（由网景提出，被大部分浏览器支持）</li>\n<li>Refresh: 5; url=http://www.zcmhi.com/archives/94.html</li>\n</ul>\n</li>\n<li>Retry-After\n<ul>\n<li>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</li>\n<li>Retry-After: 120</li>\n</ul>\n</li>\n<li>Server\n<ul>\n<li>web 服务器软件名称</li>\n<li>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</li>\n</ul>\n</li>\n<li>Set-Cookie\n<ul>\n<li>设置 Http Cookie</li>\n<li>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</li>\n</ul>\n</li>\n<li>Strict-Transport-Security\n<ul>\n<li>设置浏览器强制使用 HTTPS 访问</li>\n<li>max-age: x 秒的时间内 访问对应域名都使用 HTTPS 请求</li>\n<li>includeSubDomains: 网站的子域名也启用规则</li>\n<li>Strict-Transport-Security: max-age=1000; includeSubDomains</li>\n</ul>\n</li>\n<li>Trailer\n<ul>\n<li>指出头域在分块传输编码的尾部存在</li>\n<li>Trailer: Max-Forwards</li>\n</ul>\n</li>\n<li>Transfer-Encoding\n<ul>\n<li>文件传输编码</li>\n<li>Transfer-Encoding:chunked</li>\n</ul>\n</li>\n<li>Vary\n<ul>\n<li>告诉下游代理是使用缓存响应还是从原始服务器请求</li>\n<li>Vary: *</li>\n</ul>\n</li>\n<li>Via\n<ul>\n<li>告知代理客户端响应是通过哪里发送的</li>\n<li>Via: 1.0 fred, 1.1 <span class=\"exturl\" data-url=\"aHR0cDovL25vd2hlcmUuY29t\">nowhere.com</span> (Apache/1.1)</li>\n</ul>\n</li>\n<li>Warning\n<ul>\n<li>警告实体可能存在的问题</li>\n<li>Warning: 199 Miscellaneous warning</li>\n</ul>\n</li>\n<li>WWW-Authenticate\n<ul>\n<li>表明客户端请求实体应该使用的授权方案</li>\n<li>WWW-Authenticate: Basic</li>\n</ul>\n</li>\n<li>X-Content-Type-Options\n<ul>\n<li>配置禁止 MIME 类型嗅探</li>\n<li>X-Content-Type-Options: nosniff</li>\n</ul>\n</li>\n<li>X-Frame-Options\n<ul>\n<li>配置页面是否能出现在 &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt; 等标签中，防止点击劫持</li>\n<li>X-Frame-Options: deny</li>\n</ul>\n</li>\n<li>X-XSS-Protection\n<ul>\n<li>配置 XSS 防护机制</li>\n<li>X-XSS-Protection: 1; mode=block</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"http状态返回代码-1xx临时响应\"><a class=\"anchor\" href=\"#http状态返回代码-1xx临时响应\">#</a> HTTP 状态返回代码 1xx（临时响应）</h2>\n<p>表示临时响应并需要请求者继续执行操作的状态代码。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>继续</td>\n<td>服务器返回此代码表示已收到请求的第一部分，正在等待其余部分</td>\n</tr>\n<tr>\n<td>101</td>\n<td>切换协议</td>\n<td>请求者已要求服务器切换协议，服务器已确认并准备切换</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http状态返回代码-2xx-成功\"><a class=\"anchor\" href=\"#http状态返回代码-2xx-成功\">#</a> HTTP 状态返回代码 2xx （成功）</h2>\n<p>表示成功处理了请求的状态代码。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>成功</td>\n<td>服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页</td>\n</tr>\n<tr>\n<td>201</td>\n<td>已创建</td>\n<td>请求成功并且服务器创建了新的资源</td>\n</tr>\n<tr>\n<td>202</td>\n<td>已接受</td>\n<td>服务器已接受请求，但尚未处理</td>\n</tr>\n<tr>\n<td>203</td>\n<td>非授权信息</td>\n<td>服务器已成功处理了请求，但返回的信息可能来自另一来源</td>\n</tr>\n<tr>\n<td>204</td>\n<td>无内容</td>\n<td>服务器成功处理了请求，但没有返回任何内容</td>\n</tr>\n<tr>\n<td>205</td>\n<td>重置内容</td>\n<td>m 服务器成功处理了请求，但没有返回任何内容</td>\n</tr>\n<tr>\n<td>206</td>\n<td>部分内容</td>\n<td>服务器成功处理了部分 GET 请求</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http状态返回代码-3xx-重定向\"><a class=\"anchor\" href=\"#http状态返回代码-3xx-重定向\">#</a> HTTP 状态返回代码 3xx （重定向）</h2>\n<p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>300</td>\n<td>多种选择</td>\n<td>针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>永久移动</td>\n<td>请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td>\n</tr>\n<tr>\n<td>302</td>\n<td>临时移动</td>\n<td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>查看其他位置</td>\n<td>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td>\n</tr>\n<tr>\n<td>304</td>\n<td>未修改</td>\n<td>自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>使用代理</td>\n<td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>临时重定向</td>\n<td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http状态返回代码-4xx请求错误\"><a class=\"anchor\" href=\"#http状态返回代码-4xx请求错误\">#</a> HTTP 状态返回代码 4xx（请求错误）</h2>\n<p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>错误请求</td>\n<td>服务器不理解请求的语法。</td>\n</tr>\n<tr>\n<td>401</td>\n<td>未授权</td>\n<td>请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>禁止</td>\n<td>服务器拒绝请求。</td>\n</tr>\n<tr>\n<td>404</td>\n<td>未找到</td>\n<td>服务器找不到请求的网页。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>方法禁用</td>\n<td>禁用请求中指定的方法。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>不接受</td>\n<td>无法使用请求的内容特性响应请求的网页。</td>\n</tr>\n<tr>\n<td>407</td>\n<td>需要代理授权</td>\n<td>此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>请求超时</td>\n<td>服务器等候请求时发生超时。</td>\n</tr>\n<tr>\n<td>409</td>\n<td>冲突</td>\n<td>服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</td>\n</tr>\n<tr>\n<td>410</td>\n<td>已删除</td>\n<td>如果请求的资源已永久删除，服务器就会返回此响应。</td>\n</tr>\n<tr>\n<td>411</td>\n<td>需要有效长度</td>\n<td>服务器不接受不含有效内容长度标头字段的请求。</td>\n</tr>\n<tr>\n<td>412</td>\n<td>未满足前提条件</td>\n<td>服务器未满足请求者在请求中设置的其中一个前提条件。</td>\n</tr>\n<tr>\n<td>413</td>\n<td>请求实体过大</td>\n<td>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td>\n</tr>\n<tr>\n<td>414</td>\n<td>请求的 URI 过长</td>\n<td>请求的 URI（通常为网址）过长，服务器无法处理。</td>\n</tr>\n<tr>\n<td>415</td>\n<td>不支持的媒体类型</td>\n<td>请求的格式不受请求页面的支持。</td>\n</tr>\n<tr>\n<td>416</td>\n<td>请求范围不符合要求</td>\n<td>如果页面无法提供请求的范围，则服务器会返回此状态代码。</td>\n</tr>\n<tr>\n<td>417</td>\n<td>未满足期望值</td>\n<td>服务器未满足 &quot;期望&quot; 请求标头字段的要求。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http状态返回代码-5xx服务器错误\"><a class=\"anchor\" href=\"#http状态返回代码-5xx服务器错误\">#</a> HTTP 状态返回代码 5xx（服务器错误）</h2>\n<p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>服务器内部错误</td>\n<td>服务器遇到错误，无法完成请求。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>尚未实施</td>\n<td>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td>\n</tr>\n<tr>\n<td>502</td>\n<td>错误网关</td>\n<td>服务器作为网关或代理，从上游服务器收到无效响应。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>服务不可用</td>\n<td>服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</td>\n</tr>\n<tr>\n<td>504</td>\n<td>网关超时</td>\n<td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP 版本不受支持</td>\n<td>服务器不支持请求中所用的 HTTP 协议版本。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"http-版本\"><a class=\"anchor\" href=\"#http-版本\">#</a> HTTP 版本</h1>\n<h2 id=\"http\"><a class=\"anchor\" href=\"#http\">#</a> HTTP</h2>\n<p>HTTP 是基于 TCP/IP 协议的应用层协议，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。</p>\n<h2 id=\"http-09\"><a class=\"anchor\" href=\"#http-09\">#</a> HTTP 0.9</h2>\n<p>HTTP 0.9 最早在 1991 年发布，仅支持 GET 命令，请求格式只有简单的  <code>GET /url</code>  ，服务端仅响应 HTML，响应完毕后关闭 TCP 连接。</p>\n<h2 id=\"http-10\"><a class=\"anchor\" href=\"#http-10\">#</a> HTTP 1.0</h2>\n<p>1996 年 5 月，HTTP/1.0 版本发布，丰富了传输的格式和内容，还引入了 POST、HEAD 两个动词。从 1.0 开始，必须在尾部添加协议版本。在 1.0 中，也引入了状态码 (status code)、多字符集支持、多部分发送 (multi-part type)、权限 (authorization)、缓存 (cache)、内容编码 (content encoding) 等内容。</p>\n<p>HTTP 1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>\n<p>TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢 (slow start)，所以，HTTP 1.0 版本的性能比较差。</p>\n<h2 id=\"http-11\"><a class=\"anchor\" href=\"#http-11\">#</a> HTTP 1.1</h2>\n<p>1997 年 1 月，HTTP/1.1 版本发布，进一步完善了 HTTP 协议。1.1 版本主要是引入了持久连接、管道机制、Content-Length、分块传输编码等内容。管道机制即在同一个 TCP 连接里面，客户端可以同时发送多个请求，这样就改进了 HTTP 协议的效率。PUT、PATCH、HEAD、 OPTIONS、DELETE 等动词方法也是在 HTTP 1.1 版本引入的。另外 1.1 版本新增了 Host 字段，用于指定服务器的域名，这也是后来虚拟主机得以发展的基础。</p>\n<p>虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。如果有一个请求很慢，就会阻塞后面的请求。</p>\n<h2 id=\"spdy\"><a class=\"anchor\" href=\"#spdy\">#</a> SPDY</h2>\n<p>2009 年，谷歌公开了自行研发的 SPDY 协议，用于解决 HTTP/1.1 效率不高的问题，而后被当做 HTTP/2 的基础。</p>\n<h2 id=\"http2\"><a class=\"anchor\" href=\"#http2\">#</a> HTTP/2</h2>\n<p>2015 年，HTTP/2 发布，HTTP/2 是一个二进制协议，头信息和数据体都是二进制，统称为帧 (frame)，帧分为头信息帧和数据帧。HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序回应。</p>\n<h1 id=\"https\"><a class=\"anchor\" href=\"#https\">#</a> HTTPS</h1>\n<h2 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h2>\n<p>HTTPS (HyperText Transfer Protocol over Secure Socket Layer) 可以理解为 HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。</p>\n<h2 id=\"交互\"><a class=\"anchor\" href=\"#交互\">#</a> 交互</h2>\n<h3 id=\"证书验证阶段\"><a class=\"anchor\" href=\"#证书验证阶段\">#</a> 证书验证阶段</h3>\n<ul>\n<li>浏览器发起 HTTPS 请求</li>\n<li>服务端返回 HTTPS 证书\n<ul>\n<li>其中证书包含：\n<ul>\n<li>颁发机构信息</li>\n<li>公钥</li>\n<li>公司信息</li>\n<li>域名</li>\n<li>有效期</li>\n<li>指纹</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>客户端验证证书是否合法，如果不合法则提示告警</li>\n</ul>\n<h3 id=\"数据传输阶段\"><a class=\"anchor\" href=\"#数据传输阶段\">#</a> 数据传输阶段</h3>\n<ul>\n<li>当证书验证合法后，在本地生成随机数</li>\n<li>通过公钥加密随机数，并把加密后的随机数传输到服务端</li>\n<li>服务端通过私钥对随机数进行解密</li>\n<li>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</li>\n</ul>\n<h2 id=\"ca\"><a class=\"anchor\" href=\"#ca\">#</a> CA</h2>\n<p>CA (Certificate Authority) 是颁发数字证书的机构。是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p>\n<h1 id=\"websocket\"><a class=\"anchor\" href=\"#websocket\">#</a> WebSocket</h1>\n<h2 id=\"简介-2\"><a class=\"anchor\" href=\"#简介-2\">#</a> 简介</h2>\n<p>WebSocket 是一种网络传输协议，可在单个 TCP 连接上进行全双工通信，位于 OSI 模型的应用层。WebSocket 协议在 2011 年由 IETF 标准化为 RFC 6455，后由 RFC 7936 补充规范。</p>\n<h2 id=\"交互-2\"><a class=\"anchor\" href=\"#交互-2\">#</a> 交互</h2>\n<h3 id=\"握手\"><a class=\"anchor\" href=\"#握手\">#</a> 握手</h3>\n<p>握手阶段和 HTTP 协议较为类似，RFC 文档中给出的握手示例如下：</p>\n<pre><code>GET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nOrigin: http://example.com\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n</code></pre>\n<p>其中 Upgrade 的值必须为 websocket ，Connection 的值必须为 Upgrade ，合起来表示客户端喜欢连接升级到 Websocket 协议。</p>\n<p>Sec-WebSocket-Key 是一个随机值，Sec-WebSocket-Accept 是 Sec-WebSocket-Key 拼接特定字符串  <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>  计算 SHA1 摘要后的 Base64 编码的值。例子中  <code>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</code>  就是  <code>dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>  对应的 SHA1 摘要。</p>\n<h1 id=\"cookie\"><a class=\"anchor\" href=\"#cookie\">#</a> Cookie</h1>\n<h2 id=\"2751-简介\"><a class=\"anchor\" href=\"#2751-简介\">#</a> 2.7.5.1. 简介</h2>\n<p>Cookie（复数形态 Cookies），类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。</p>\n<h2 id=\"2752-属性\"><a class=\"anchor\" href=\"#2752-属性\">#</a> 2.7.5.2. 属性</h2>\n<h3 id=\"name\"><a class=\"anchor\" href=\"#name\">#</a> name</h3>\n<p>cookie 的名称。</p>\n<h3 id=\"value\"><a class=\"anchor\" href=\"#value\">#</a> value</h3>\n<p>cookie 的值。</p>\n<h3 id=\"expires\"><a class=\"anchor\" href=\"#expires\">#</a> expires</h3>\n<p>当 Expires 属性缺省时，表示是会话性 Cookie，在用户关闭浏览器时失效。</p>\n<h3 id=\"max-age\"><a class=\"anchor\" href=\"#max-age\">#</a> max-age</h3>\n<p>max-age 可以为正数、负数、0。如果 max-age 属性为正数时，浏览器会将其持久化，当 max-age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。当 max-age 为 0 时，则会立即删除这个 Cookie。Expires 和 max-age 都存在的条件下，max-age 优先级更高。</p>\n<h3 id=\"domain\"><a class=\"anchor\" href=\"#domain\">#</a> domain</h3>\n<p>指定 Cookie 的域名，默认是当前域名。domain 设置时可以设置为自身及其父域，子域可以访问父域的 Cookie，反之不能。</p>\n<h3 id=\"path\"><a class=\"anchor\" href=\"#path\">#</a> path</h3>\n<p>指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送对应的 Cookie。</p>\n<h3 id=\"secure\"><a class=\"anchor\" href=\"#secure\">#</a> secure</h3>\n<p>只能通过 HTTPS 传输。</p>\n<h3 id=\"httponly\"><a class=\"anchor\" href=\"#httponly\">#</a> httponly</h3>\n<p>限制 Cookie 仅在 HTTP 传输过程中被读取，一定程度上防御 XSS 攻击。</p>\n<h3 id=\"samesite\"><a class=\"anchor\" href=\"#samesite\">#</a> SameSite</h3>\n<p>SameSite 支持 Strict / Lax / None 三种值。Strict 最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。Lax 允许部分第三方请求携带 Cookie，主要是链接、预加载、GET 表单三种情况。Cookie 的 SameSite 属性为 None ，且设置了 Secure 时，无论是否跨站都会发送 Cookie。</p>\n<h1 id=\"webdav\"><a class=\"anchor\" href=\"#webdav\">#</a> WebDAV</h1>\n<h2 id=\"简介-3\"><a class=\"anchor\" href=\"#简介-3\">#</a> 简介</h2>\n<p>WebDAV （Web-based Distributed Authoring and Versioning） 一种基于 HTTP 1.1 协议的通信协议。它扩展了 HTTP 1.1，在 GET、POST、HEAD 等几个 HTTP 标准方法以外添加了一些新的方法，使应用程序可对 Web Server 直接读写，并支持写文件锁定、解锁，以及版本控制等功能。</p>\n<p>支持的方法具体为：</p>\n<ul>\n<li>OPTIONS\n<ul>\n<li>获取服务器的支持</li>\n</ul>\n</li>\n<li>GET / PUT / POST / DELETE\n<ul>\n<li>资源操作</li>\n</ul>\n</li>\n<li>TRACE\n<ul>\n<li>跟踪服务器</li>\n</ul>\n</li>\n<li>HEAD</li>\n<li>MKCOL\n<ul>\n<li>创建集合</li>\n</ul>\n</li>\n<li>PROPFIND / PROPPATCH</li>\n<li>COPY / MOVE</li>\n<li>LOCK / UNLOCK</li>\n</ul>\n<h2 id=\"相关cve\"><a class=\"anchor\" href=\"#相关cve\">#</a> 相关 CVE</h2>\n<ul>\n<li>CVE-2015-1833\n<ul>\n<li>Apache Jacrabbit WebDav XXE</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zZWN1cml0eWZvY3VzLmNvbS9hcmNoaXZlLzEvNTM1NTgy\">http://www.securityfocus.com/archive/1/535582</span></li>\n</ul>\n</li>\n<li>CVE-2015-7326\n<ul>\n<li>Milton WebDav XXE</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zZWN1cml0eWZvY3VzLmNvbS9hcmNoaXZlLzEvNTM2ODEz\">http://www.securityfocus.com/archive/1/536813</span></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h1>\n<h2 id=\"rfc\"><a class=\"anchor\" href=\"#rfc\">#</a> RFC</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNTM=\">RFC 3253</span> Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2NDg=\">RFC 3648</span> Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM3NDQ=\">RFC 3744</span> Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ0Mzc=\">RFC 4437</span> Web Distributed Authoring and Versioning (WebDAV) Redirect Reference Resources</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ5MTg=\">RFC 4918</span> HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjM=\">RFC 5323</span> Web Distributed Authoring and Versioning (WebDAV) SEARCH</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU4NDI=\">RFC 5842</span> Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1\">The WebSocket Protocol</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3OTM2\">Clarifying Registry Procedures for the WebSocket Subprotocol Name Registry</span></li>\n</ul>\n<h2 id=\"blog\"><a class=\"anchor\" href=\"#blog\">#</a> Blog</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovLzIwMTUuemVyb25pZ2h0cy5vcmcvYXNzZXRzL2ZpbGVzLzM1LUVnb3Jvdi5wZGY=\">What should a hacker know about WebDav</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTkvMDkvY29va2llLXNhbWVzaXRlLmh0bWw=\">Cookie 的 SameSite 属性</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDgvaHR0cC5odG1s\">HTTP 协议入门</span></li>\n</ul>\n",
            "tags": [
                "HTTP"
            ]
        }
    ]
}